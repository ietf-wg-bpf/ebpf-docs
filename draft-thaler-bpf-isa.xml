<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
  <!-- generated by https://github.com/dthaler/rst2rfcxml version 0.1 -->

<!DOCTYPE rfc [
]>

<?rfc rfcedstyle="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-thaler-bpf-isa-00" category="std" submissionType="IETF">
 <front>
  <title abbrev="eBPF ISA">
eBPF Instruction Set Specification, v1.0
  </title>
  <author initials="D." surname="Thaler" fullname="Dave Thaler" role="editor">
    <organization>Microsoft</organization>
   <address>
    <postal>
    <city>Redmond</city>
    <code>98052</code>
    <country>USA</country>
    <region>WA</region>
    </postal>
    <email>dthaler@microsoft.com</email>
   </address>
  </author>
  <abstract>
   <t>
    This document specifies version 1.0 of the eBPF instruction set.
   </t>
   <t>
    The eBPF instruction set consists of eleven 64 bit registers, a program counter,
    and an implementation-specific amount (e.g., 512 bytes) of stack space.
   </t>
  </abstract>
 </front>
 <middle>
  <section anchor="documentation-conventions" title="Documentation conventions">
   <t>
    For brevity, this document uses the type notion "u64", "u32", etc.
    to mean an unsigned integer whose width is the specified number of bits,
    and "s32", etc. to mean a signed integer of the specified number of bits.
   </t>
  </section>
  <section anchor="registers-and-calling-convention" title="Registers and calling convention">
   <t>
    eBPF has 10 general purpose registers and a read-only frame pointer register,
    all of which are 64-bits wide.
   </t>
   <t>
    The eBPF calling convention is defined as:
   </t>
   <ul>
    <li>
     R0: return value from function calls, and exit value for eBPF programs
    </li>
    <li>
     R1 - R5: arguments for function calls
    </li>
    <li>
     R6 - R9: callee saved registers that function calls will preserve
    </li>
    <li>
     R10: read-only frame pointer to access stack
    </li>
   </ul>
   <t>
    Registers R0 - R5 are caller-saved registers, meaning the BPF program needs to either
    spill them to the BPF stack or move them to callee saved registers if these
    arguments are to be reused across multiple function calls. Spilling means
    that the value in the register is moved to the BPF stack. The reverse operation
    of moving the variable from the BPF stack to the register is called filling.
    The reason for spilling/filling is due to the limited number of registers.
   </t>
   <t>
    Upon entering execution of an eBPF program, registers R1 - R5 initially can contain
    the input arguments for the program (similar to the argc/argv pair for a typical C program).
    The actual number of registers used, and their meaning, is defined by the program type;
    for example, a networking program might have an argument that includes network packet data
    and/or metadata.
   </t>
  </section>
  <section anchor="instruction-encoding" title="Instruction encoding">
   <t>
    An eBPF program is a sequence of instructions.
   </t>
   <t>
    eBPF has two instruction encodings:
   </t>
   <ul>
    <li>
     the basic instruction encoding, which uses 64 bits to encode an instruction
    </li>
    <li>
     the wide instruction encoding, which appends a second 64-bit immediate (i.e.,
     constant) value after the basic instruction for a total of 128 bits.
    </li>
   </ul>
   <t>
    The fields conforming an encoded basic instruction are stored in the
    following order:
    <artwork>
  opcode:8 src_reg:4 dst_reg:4 offset:16 imm:32 // In little-endian BPF.
  opcode:8 dst_reg:4 src_reg:4 offset:16 imm:32 // In big-endian BPF.
    </artwork>
   </t>
   <dl>
    <dt>
     <strong>imm</strong>
    </dt>
    <dd>
     signed integer immediate value
    </dd>
    <dt>
     <strong>offset</strong>
    </dt>
    <dd>
     signed integer offset used with pointer arithmetic
    </dd>
    <dt>
     <strong>src_reg</strong>
    </dt>
    <dd>
     the source register number (0-10), except where otherwise specified
     (<xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref> reuse this field for other purposes)
    </dd>
    <dt>
     <strong>dst_reg</strong>
    </dt>
    <dd>
     destination register number (0-10)
    </dd>
    <dt>
     <strong>opcode</strong>
    </dt>
    <dd>
     operation to perform
    </dd>
   </dl>
   <t>
    Note that the contents of multi-byte fields ('imm' and 'offset') are
    stored using big-endian byte ordering in big-endian BPF and
    little-endian byte ordering in little-endian BPF.
   </t>
   <t>
    For example:
   </t>
   <artwork>
  opcode                  offset imm          assembly
         src_reg dst_reg
  07     0       1        00 00  44 33 22 11  r1 += 0x11223344 // little
         dst_reg src_reg
  07     1       0        00 00  11 22 33 44  r1 += 0x11223344 // big
   </artwork>
   <t>
    Note that most instructions do not use all of the fields.
    Unused fields must be set to zero.
   </t>
   <t>
    As discussed below in <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>, a 64-bit immediate
    instruction uses a 64-bit immediate value that is constructed as follows.
    The 64 bits following the basic instruction contain a pseudo instruction
    using the same format but with opcode, dst_reg, src_reg, and offset all set to zero,
    and imm containing the high 32 bits of the immediate value.
   </t>
   <t>
    This is depicted in the following figure:
   </t>
   <artwork>
        basic_instruction
  .-----------------------------.
  |                             |
  code:8 regs:8 offset:16 imm:32 unused:32 imm:32
                                 |              |
                                 '--------------'
                                pseudo instruction
   </artwork>
   <t>
    Thus the 64-bit immediate value is constructed as follows:
   </t>
   <blockquote>
    imm64 = (next_imm &lt;&lt; 32) | imm
   </blockquote>
   <t>
    where 'next_imm' refers to the imm value of the pseudo instruction
    following the basic instruction.  The unused bytes in the pseudo
    instruction are reserved and shall be cleared to zero.
   </t>
   <section anchor="instruction-classes" title="Instruction classes">
    <t>
     The encoding of the 'opcode' field varies and can be determined from
     the three least significant bits (LSB) of the 'opcode' field which holds
     the "instruction class", as follows:
    </t>
    <table>
     <thead>
      <tr>
       <th>class</th>
       <th>value</th>
       <th>description</th>
       <th>reference</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x00
        </t>
       </td>
       <td>
        <t>
         non-standard load operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_LDX
        </t>
       </td>
       <td>
        <t>
         0x01
        </t>
       </td>
       <td>
        <t>
         load into register operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_ST
        </t>
       </td>
       <td>
        <t>
         0x02
        </t>
       </td>
       <td>
        <t>
         store from immediate operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_STX
        </t>
       </td>
       <td>
        <t>
         0x03
        </t>
       </td>
       <td>
        <t>
         store from register operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_ALU
        </t>
       </td>
       <td>
        <t>
         0x04
        </t>
       </td>
       <td>
        <t>
         32-bit arithmetic operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JMP
        </t>
       </td>
       <td>
        <t>
         0x05
        </t>
       </td>
       <td>
        <t>
         64-bit jump operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JMP32
        </t>
       </td>
       <td>
        <t>
         0x06
        </t>
       </td>
       <td>
        <t>
         32-bit jump operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_ALU64
        </t>
       </td>
       <td>
        <t>
         0x07
        </t>
       </td>
       <td>
        <t>
         64-bit arithmetic operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
     </tbody>
    </table>
   </section>
  </section>
  <section anchor="arithmetic-and-jump-instructions" title="Arithmetic and jump instructions">
   <t>
    For arithmetic and jump instructions (<tt>BPF_ALU</tt>, <tt>BPF_ALU64</tt>, <tt>BPF_JMP</tt> and
    <tt>BPF_JMP32</tt>), the 8-bit 'opcode' field is divided into three parts:
   </t>
   <table>
    <thead>
     <tr>
      <th>4 bits (MSB)</th>
      <th>1 bit</th>
      <th>3 bits (LSB)</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        code
       </t>
      </td>
      <td>
       <t>
        source
       </t>
      </td>
      <td>
       <t>
        instruction class
       </t>
      </td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt>
     <strong>code</strong>
    </dt>
    <dd>
     the operation code, whose meaning varies by instruction class
    </dd>
    <dt>
     <strong>source</strong>
    </dt>
    <dd>
     the source operand location, which unless otherwise specified is one of:
    </dd>
   </dl>
   <table>
    <thead>
     <tr>
      <th>source</th>
      <th>value</th>
      <th>description</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        BPF_K
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        use 32-bit 'imm' value as source operand
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_X
       </t>
      </td>
      <td>
       <t>
        0x08
       </t>
      </td>
      <td>
       <t>
        use 'src_reg' register value as source operand
       </t>
      </td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt>
     <strong>instruction class</strong>
    </dt>
    <dd>
     the instruction class (see <xref target="instruction-classes">Instruction classes</xref>)
    </dd>
   </dl>
   <section anchor="arithmetic-instructions" title="Arithmetic instructions">
    <t>
     Instruction class <tt>BPF_ALU</tt> uses 32-bit wide operands (zeroing the upper 32 bits
     of the destination register) while <tt>BPF_ALU64</tt> uses 64-bit wide operands for
     otherwise identical operations.
     The 'code' field encodes the operation as below, where 'src' and 'dst' refer
     to the values of the source and destination registers, respectively.
    </t>
    <table>
     <thead>
      <tr>
       <th>code</th>
       <th>value</th>
       <th>description</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_ADD
        </t>
       </td>
       <td>
        <t>
         0x00
        </t>
       </td>
       <td>
        <t>
         dst += src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_SUB
        </t>
       </td>
       <td>
        <t>
         0x10
        </t>
       </td>
       <td>
        <t>
         dst -= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_MUL
        </t>
       </td>
       <td>
        <t>
         0x20
        </t>
       </td>
       <td>
        <t>
         dst *= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_DIV
        </t>
       </td>
       <td>
        <t>
         0x30
        </t>
       </td>
       <td>
        <t>
         dst = (src != 0) ? (dst / src) : 0
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_OR
        </t>
       </td>
       <td>
        <t>
         0x40
        </t>
       </td>
       <td>
        <t>
         dst |= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_AND
        </t>
       </td>
       <td>
        <t>
         0x50
        </t>
       </td>
       <td>
        <t>
         dst &amp;= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_LSH
        </t>
       </td>
       <td>
        <t>
         0x60
        </t>
       </td>
       <td>
        <t>
         dst &lt;&lt;= (src &amp; mask)
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_RSH
        </t>
       </td>
       <td>
        <t>
         0x70
        </t>
       </td>
       <td>
        <t>
         dst &gt;&gt;= (src &amp; mask)
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_NEG
        </t>
       </td>
       <td>
        <t>
         0x80
        </t>
       </td>
       <td>
        <t>
         dst = -src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_MOD
        </t>
       </td>
       <td>
        <t>
         0x90
        </t>
       </td>
       <td>
        <t>
         dst = (src != 0) ? (dst % src) : dst
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_XOR
        </t>
       </td>
       <td>
        <t>
         0xa0
        </t>
       </td>
       <td>
        <t>
         dst ^= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_MOV
        </t>
       </td>
       <td>
        <t>
         0xb0
        </t>
       </td>
       <td>
        <t>
         dst = src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_ARSH
        </t>
       </td>
       <td>
        <t>
         0xc0
        </t>
       </td>
       <td>
        <t>
         sign extending dst &gt;&gt;= (src &amp; mask)
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_END
        </t>
       </td>
       <td>
        <t>
         0xd0
        </t>
       </td>
       <td>
        <t>
         byte swap operations (see <xref target="byte-swap-instructions">Byte swap instructions</xref> below)
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     Underflow and overflow are allowed during arithmetic operations, meaning
     the 64-bit or 32-bit value will wrap. If eBPF program execution would
     result in division by zero, the destination register is instead set to zero.
     If execution would result in modulo by zero, for <tt>BPF_ALU64</tt> the value of
     the destination register is unchanged whereas for <tt>BPF_ALU</tt> the upper
     32 bits of the destination register are zeroed.
    </t>
    <t>
     Examples:
    </t>
    <t>
     <tt>BPF_ADD | BPF_X | BPF_ALU</tt> (0x0c) means:
    </t>
    <artwork>
  dst = (u32) ((u32) dst + (u32) src)
    </artwork>
    <t>
     where '(u32)' indicates that the upper 32 bits are zeroed.
    </t>
    <t>
     <tt>BPF_ADD | BPF_X | BPF_ALU64</tt> (0x0f) means:
    </t>
    <artwork>
  dst = dst + src
    </artwork>
    <t>
     <tt>BPF_XOR | BPF_K | BPF_ALU</tt> (0xa4) means:
    </t>
    <artwork>
  dst = (u32) dst ^ (u32) imm32
    </artwork>
    <t>
     <tt>BPF_XOR | BPF_K | BPF_ALU64</tt> (0xa7) means:
    </t>
    <artwork>
  dst = dst ^ imm32
    </artwork>
    <t>
     Also note that the division and modulo operations are unsigned. Thus, for
     <tt>BPF_ALU</tt>, 'imm' is first interpreted as an unsigned 32-bit value, whereas
     for <tt>BPF_ALU64</tt>, 'imm' is first sign extended to 64 bits and the result
     interpreted as an unsigned 64-bit value. There are no instructions for
     signed division or modulo.
    </t>
    <t>
     Shift operations use a mask of 0x3F (63) for 64-bit operations and 0x1F (31)
     for 32-bit operations.
    </t>
    <section anchor="byte-swap-instructions" title="Byte swap instructions">
     <t>
      The byte swap instructions use an instruction class of <tt>BPF_ALU</tt> and a 4-bit
      'code' field of <tt>BPF_END</tt>.
     </t>
     <t>
      The byte swap instructions operate on the destination register
      only and do not use a separate source register or immediate value.
     </t>
     <t>
      Byte swap instructions use the 1-bit 'source' field in the 'opcode' field
      as follows.  Instead of indicating the source operator, it is instead
      used to select what byte order the operation converts from or to:
     </t>
     <table>
      <thead>
       <tr>
        <th>source</th>
        <th>value</th>
        <th>description</th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
         <t>
          BPF_TO_LE
         </t>
        </td>
        <td>
         <t>
          0x00
         </t>
        </td>
        <td>
         <t>
          convert between host byte order and little endian
         </t>
        </td>
       </tr>
       <tr>
        <td>
         <t>
          BPF_TO_BE
         </t>
        </td>
        <td>
         <t>
          0x08
         </t>
        </td>
        <td>
         <t>
          convert between host byte order and big endian
         </t>
        </td>
       </tr>
      </tbody>
     </table>
     <t>
      The 'imm' field encodes the width of the swap operations.  The following widths
      are supported: 16, 32 and 64.
     </t>
     <t>
      Examples:
     </t>
     <t>
      <tt>BPF_ALU | BPF_TO_LE | BPF_END</tt> with imm = 16 means:
     </t>
     <artwork>
  dst = htole16(dst)
     </artwork>
     <t>
      where 'htole16()' indicates converting a 16-bit value from host byte order to little-endian byte order.
     </t>
     <t>
      <tt>BPF_ALU | BPF_TO_BE | BPF_END</tt> with imm = 64 means:
     </t>
     <artwork>
  dst = htobe64(dst)
     </artwork>
     <t>
      where 'htobe64()' indicates converting a 64-bit value from host byte order to big-endian byte order.
     </t>
    </section>
   </section>
   <section anchor="jump-instructions" title="Jump instructions">
    <t>
     Instruction class <tt>BPF_JMP32</tt> uses 32-bit wide operands while <tt>BPF_JMP</tt> uses 64-bit wide operands for
     otherwise identical operations.
    </t>
    <t>
     The 4-bit 'code' field encodes the operation as below, where PC is the program counter:
    </t>
    <table>
     <thead>
      <tr>
       <th>code</th>
       <th>value</th>
       <th>src</th>
       <th>description</th>
       <th>notes</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_JA
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         PC += offset
        </t>
       </td>
       <td>
        <t>
         BPF_JMP only
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JEQ
        </t>
       </td>
       <td>
        <t>
         0x1
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst == src
        </t>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JGT
        </t>
       </td>
       <td>
        <t>
         0x2
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt; src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JGE
        </t>
       </td>
       <td>
        <t>
         0x3
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt;= src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JSET
        </t>
       </td>
       <td>
        <t>
         0x4
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &amp; src
        </t>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JNE
        </t>
       </td>
       <td>
        <t>
         0x5
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst != src
        </t>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JSGT
        </t>
       </td>
       <td>
        <t>
         0x6
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt; src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JSGE
        </t>
       </td>
       <td>
        <t>
         0x7
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt;= src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_CALL
        </t>
       </td>
       <td>
        <t>
         0x8
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         call helper function by address
        </t>
       </td>
       <td>
        <t>
         see <xref target="helper-functions">Helper functions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_CALL
        </t>
       </td>
       <td>
        <t>
         0x8
        </t>
       </td>
       <td>
        <t>
         0x1
        </t>
       </td>
       <td>
        <t>
         call PC += offset
        </t>
       </td>
       <td>
        <t>
         see <xref target="program-local-functions">Program-local functions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_CALL
        </t>
       </td>
       <td>
        <t>
         0x8
        </t>
       </td>
       <td>
        <t>
         0x2
        </t>
       </td>
       <td>
        <t>
         call helper function by BTF ID
        </t>
       </td>
       <td>
        <t>
         see <xref target="helper-functions">Helper functions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_EXIT
        </t>
       </td>
       <td>
        <t>
         0x9
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         return
        </t>
       </td>
       <td>
        <t>
         BPF_JMP only
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JLT
        </t>
       </td>
       <td>
        <t>
         0xa
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt; src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JLE
        </t>
       </td>
       <td>
        <t>
         0xb
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt;= src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JSLT
        </t>
       </td>
       <td>
        <t>
         0xc
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt; src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JSLE
        </t>
       </td>
       <td>
        <t>
         0xd
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt;= src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     The eBPF program needs to store the return value into register R0 before doing a
     <tt>BPF_EXIT</tt>.
    </t>
    <t>
     Example:
    </t>
    <t>
     <tt>BPF_JSGE | BPF_X | BPF_JMP32</tt> (0x7e) means:
    </t>
    <artwork>
  if (s32)dst s&gt;= (s32)src goto +offset
    </artwork>
    <t>
     where 's&gt;=' indicates a signed '&gt;=' comparison.
    </t>
    <section anchor="helper-functions" title="Helper functions">
     <t>
      Helper functions are a concept whereby BPF programs can call into a
      set of function calls exposed by the underlying platform.
     </t>
     <t>
      Historically, each helper function was identified by an address
      encoded in the imm field.  The available helper functions may differ
      for each program type, but address values are unique across all program types.
     </t>
     <t>
      Platforms that support the BPF Type Format (BTF) support identifying
      a helper function by a BTF ID encoded in the imm field, where the BTF ID
      identifies the helper name and type.
     </t>
    </section>
    <section anchor="program-local-functions" title="Program-local functions">
     <t>
      Program-local functions are functions exposed by the same BPF program as the
      caller, and are referenced by offset from the call instruction, similar to
      <tt>BPF_JA</tt>.  A <tt>BPF_EXIT</tt> within the program-local function will return to
      the caller.
     </t>
    </section>
   </section>
  </section>
  <section anchor="load-and-store-instructions" title="Load and store instructions">
   <t>
    For load and store instructions (<tt>BPF_LD</tt>, <tt>BPF_LDX</tt>, <tt>BPF_ST</tt>, and <tt>BPF_STX</tt>), the
    8-bit 'opcode' field is divided as:
   </t>
   <table>
    <thead>
     <tr>
      <th>3 bits (MSB)</th>
      <th>2 bits</th>
      <th>3 bits (LSB)</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        mode
       </t>
      </td>
      <td>
       <t>
        size
       </t>
      </td>
      <td>
       <t>
        instruction class
       </t>
      </td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt>
     mode
    </dt>
    <dd>
     one of:
    </dd>
   </dl>
   <table>
    <thead>
     <tr>
      <th>mode modifier</th>
      <th>value</th>
      <th>description</th>
      <th>reference</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        BPF_IMM
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        64-bit immediate instructions
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_ABS
       </t>
      </td>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        legacy BPF packet access (absolute)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_IND
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        legacy BPF packet access (indirect)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_MEM
       </t>
      </td>
      <td>
       <t>
        0x60
       </t>
      </td>
      <td>
       <t>
        regular load and store operations
       </t>
      </td>
      <td>
       <t>
        <xref target="regular-load-and-store-operations">Regular load and store operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_ATOMIC
       </t>
      </td>
      <td>
       <t>
        0xc0
       </t>
      </td>
      <td>
       <t>
        atomic operations
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt>
     size
    </dt>
    <dd>
     one of:
    </dd>
   </dl>
   <table>
    <thead>
     <tr>
      <th>size modifier</th>
      <th>value</th>
      <th>description</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        BPF_W
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        word        (4 bytes)
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_H
       </t>
      </td>
      <td>
       <t>
        0x08
       </t>
      </td>
      <td>
       <t>
        half word   (2 bytes)
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_B
       </t>
      </td>
      <td>
       <t>
        0x10
       </t>
      </td>
      <td>
       <t>
        byte
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_DW
       </t>
      </td>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        double word (8 bytes)
       </t>
      </td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt>
     instruction class
    </dt>
    <dd>
     the instruction class (see <xref target="instruction-classes">Instruction classes</xref>)
    </dd>
   </dl>
   <section anchor="regular-load-and-store-operations" title="Regular load and store operations">
    <t>
     The <tt>BPF_MEM</tt> mode modifier is used to encode regular load and store
     instructions that transfer data between a register and memory.
    </t>
    <t>
     <tt>BPF_MEM | &lt;size&gt; | BPF_STX</tt> means:
    </t>
    <artwork>
  *(size *) (dst + offset) = src
    </artwork>
    <t>
     <tt>BPF_MEM | &lt;size&gt; | BPF_ST</tt> means:
    </t>
    <artwork>
  *(size *) (dst + offset) = imm32
    </artwork>
    <t>
     <tt>BPF_MEM | &lt;size&gt; | BPF_LDX</tt> means:
    </t>
    <artwork>
  dst = *(size *) (src + offset)
    </artwork>
    <t>
     where size is one of: <tt>BPF_B</tt>, <tt>BPF_H</tt>, <tt>BPF_W</tt>, or <tt>BPF_DW</tt>.
    </t>
   </section>
   <section anchor="atomic-operations" title="Atomic operations">
    <t>
     Atomic operations are operations that operate on memory and can not be
     interrupted or corrupted by other access to the same memory region
     by other eBPF programs or means outside of this specification.
    </t>
    <t>
     All atomic operations supported by eBPF are encoded as store operations
     that use the <tt>BPF_ATOMIC</tt> mode modifier as follows:
    </t>
    <ul>
     <li>
      <tt>BPF_ATOMIC | BPF_W | BPF_STX</tt> (0xc3) for 32-bit operations
     </li>
     <li>
      <tt>BPF_ATOMIC | BPF_DW | BPF_STX</tt> (0xdb) for 64-bit operations
     </li>
    </ul>
    <t>
     Note that 8-bit (<tt>BPF_B</tt>) and 16-bit (<tt>BPF_H</tt>) wide atomic operations are not currently supported,
     nor is <tt>BPF_ATOMIC | &lt;size&gt; | BPF_ST</tt>.
    </t>
    <t>
     The 'imm' field is used to encode the actual atomic operation.
     Simple atomic operation use a subset of the values defined to encode
     arithmetic operations in the 'imm' field to encode the atomic operation:
    </t>
    <table>
     <thead>
      <tr>
       <th>imm</th>
       <th>value</th>
       <th>description</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_ADD
        </t>
       </td>
       <td>
        <t>
         0x00
        </t>
       </td>
       <td>
        <t>
         atomic add
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_OR
        </t>
       </td>
       <td>
        <t>
         0x40
        </t>
       </td>
       <td>
        <t>
         atomic or
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_AND
        </t>
       </td>
       <td>
        <t>
         0x50
        </t>
       </td>
       <td>
        <t>
         atomic and
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_XOR
        </t>
       </td>
       <td>
        <t>
         0xa0
        </t>
       </td>
       <td>
        <t>
         atomic xor
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     <tt>BPF_ATOMIC | BPF_W  | BPF_STX</tt> (0xc3) with 'imm' = BPF_ADD means:
    </t>
    <artwork>
  *(u32 *)(dst + offset) += src
    </artwork>
    <t>
     <tt>BPF_ATOMIC | BPF_DW | BPF_STX</tt> (0xdb) with 'imm' = BPF ADD means:
    </t>
    <artwork>
  *(u64 *)(dst + offset) += src
    </artwork>
    <t>
     In addition to the simple atomic operations above, there also is a modifier and
     two complex atomic operations:
    </t>
    <table>
     <thead>
      <tr>
       <th>imm</th>
       <th>value</th>
       <th>description</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_FETCH
        </t>
       </td>
       <td>
        <t>
         0x01
        </t>
       </td>
       <td>
        <t>
         modifier: return old value
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_XCHG
        </t>
       </td>
       <td>
        <t>
         0xe0 | BPF_FETCH
        </t>
       </td>
       <td>
        <t>
         atomic exchange
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_CMPXCHG
        </t>
       </td>
       <td>
        <t>
         0xf0 | BPF_FETCH
        </t>
       </td>
       <td>
        <t>
         atomic compare and exchange
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     The <tt>BPF_FETCH</tt> modifier is optional for simple atomic operations, and
     always set for the complex atomic operations.  If the <tt>BPF_FETCH</tt> flag
     is set, then the operation also overwrites <tt>src</tt> with the value that
     was in memory before it was modified.
    </t>
    <t>
     The <tt>BPF_XCHG</tt> operation atomically exchanges <tt>src</tt> with the value
     addressed by <tt>dst + offset</tt>.
    </t>
    <t>
     The <tt>BPF_CMPXCHG</tt> operation atomically compares the value addressed by
     <tt>dst + offset</tt> with <tt>R0</tt>. If they match, the value addressed by
     <tt>dst + offset</tt> is replaced with <tt>src</tt>. In either case, the
     value that was at <tt>dst + offset</tt> before the operation is zero-extended
     and loaded back to <tt>R0</tt>.
    </t>
   </section>
   <section anchor="-4-bit-immediate-instructions" title="64-bit immediate instructions">
    <t>
     Instructions with the <tt>BPF_IMM</tt> 'mode' modifier use the wide instruction
     encoding defined in <xref target="instruction-encoding">Instruction encoding</xref>, and use the 'src' field of the
     basic instruction to hold an opcode subtype.
    </t>
    <t>
     The following table defines a set of <tt>BPF_IMM | BPF_DW | BPF_LD</tt> instructions
     with opcode subtypes in the 'src' field, using new terms such as "map"
     defined further below:
    </t>
    <table>
     <thead>
      <tr>
       <th>opcode construction</th>
       <th>opcode</th>
       <th>src</th>
       <th>pseudocode</th>
       <th>imm type</th>
       <th>dst type</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         dst = imm64
        </t>
       </td>
       <td>
        <t>
         integer
        </t>
       </td>
       <td>
        <t>
         integer
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x1
        </t>
       </td>
       <td>
        <t>
         dst = map_by_fd(imm)
        </t>
       </td>
       <td>
        <t>
         map fd
        </t>
       </td>
       <td>
        <t>
         map
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x2
        </t>
       </td>
       <td>
        <t>
         dst = map_val(map_by_fd(imm)) + next_imm
        </t>
       </td>
       <td>
        <t>
         map fd
        </t>
       </td>
       <td>
        <t>
         data pointer
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x3
        </t>
       </td>
       <td>
        <t>
         dst = var_addr(imm)
        </t>
       </td>
       <td>
        <t>
         variable id
        </t>
       </td>
       <td>
        <t>
         data pointer
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x4
        </t>
       </td>
       <td>
        <t>
         dst = code_addr(imm)
        </t>
       </td>
       <td>
        <t>
         integer
        </t>
       </td>
       <td>
        <t>
         code pointer
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x5
        </t>
       </td>
       <td>
        <t>
         dst = map_by_idx(imm)
        </t>
       </td>
       <td>
        <t>
         map index
        </t>
       </td>
       <td>
        <t>
         map
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x6
        </t>
       </td>
       <td>
        <t>
         dst = map_val(map_by_idx(imm)) + next_imm
        </t>
       </td>
       <td>
        <t>
         map index
        </t>
       </td>
       <td>
        <t>
         data pointer
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     where
    </t>
    <ul>
     <li>
      map_by_fd(imm) means to convert a 32-bit file descriptor into an address of a map (see <xref target="maps">Maps</xref>)
     </li>
     <li>
      map_by_idx(imm) means to convert a 32-bit index into an address of a map
     </li>
     <li>
      map_val(map) gets the address of the first value in a given map
     </li>
     <li>
      var_addr(imm) gets the address of a platform variable (see <xref target="platform-variables">Platform Variables</xref>) with a given id
     </li>
     <li>
      code_addr(imm) gets the address of the instruction at a specified relative offset in number of (64-bit) instructions
     </li>
     <li>
      the 'imm type' can be used by disassemblers for display
     </li>
     <li>
      the 'dst type' can be used for verification and JIT compilation purposes
     </li>
    </ul>
    <section anchor="maps" title="Maps">
     <t>
      Maps are shared memory regions accessible by eBPF programs on some platforms.
      A map can have various semantics as defined in a separate document, and may or
      may not have a single contiguous memory region, but the 'map_val(map)' is
      currently only defined for maps that do have a single contiguous memory region.
     </t>
     <t>
      Each map can have a file descriptor (fd) if supported by the platform, where
      'map_by_fd(imm)' means to get the map with the specified file descriptor. Each
      BPF program can also be defined to use a set of maps associated with the
      program at load time, and 'map_by_idx(imm)' means to get the map with the given
      index in the set associated with the BPF program containing the instruction.
     </t>
    </section>
    <section anchor="platform-variables" title="Platform Variables">
     <t>
      Platform variables are memory regions, identified by integer ids, exposed by
      the runtime and accessible by BPF programs on some platforms.  The
      'var_addr(imm)' operation means to get the address of the memory region
      identified by the given id.
     </t>
    </section>
   </section>
   <section anchor="legacy-bpf-packet-access-instructions" title="Legacy BPF Packet access instructions">
    <t>
     eBPF previously introduced special instructions for access to packet data that were
     carried over from classic BPF. However, these instructions are
     deprecated and should no longer be used.
    </t>
   </section>
  </section>
  <section anchor="iana-considerations" title="IANA Considerations">
   <t>
    This document proposes a new IANA registry for BPF instructions, as follows:
   </t>
   <ul>
    <li>
     Name of the registry: BPF Instruction Set
    </li>
    <li>
     Name of the registry group: same as registry name
    </li>
    <li>
     Required information for registrations: The values to appear in the entry fields.
    </li>
    <li>
     Syntax of registry entries: Each entry has the following fields:
     * opcode: a 1-byte value in hex format indicating the value of the opcode field
     * src: a 4-bit value in hex format indicating the value of the src field, or "any"
     * imm: either a value in hex format indicating the value of the imm field, or "any"
     * description: description of what the instruction does, typically in pseudocode
     * reference: a reference to the defining specification
     * status: Permanent, Provisional, or Historical
    </li>
    <li>
     Registration policy (see <xref target="RFC8126">RFC 8126 section 4</xref> for details):
     * Permanent: Standards action
     * Provisional: Specification required
     * Historical: Specification required
    </li>
    <li>
     Initial registrations: See the Appendix. Instructions other than those listed
     as deprecated are Permanent. Any listed as deprecated are Historical.
    </li>
   </ul>
  </section>
  <section anchor="acknowledgements" title="Acknowledgements">
   <t>
    This draft was generated from instruction-set.rst in the Linux
    kernel repository, to which a number of other individuals have authored contributions
    over time, including Akhil Raj, Christoph Hellwig, Jose E. Marchesi, Kosuke Fujimoto,
    Shahab Vahedi, Tiezhu Yang, and Zheng Yejian, with review and suggestions by many others including
    Alan Jowett, Alexei Starovoitov, Andrii Nakryiko, Daniel Borkmann, David Vernet, Jim Harris,
    Quentin Monnet, Song Liu, Shung-Hsi Yu, Stanislav Fomichev, and Yonghong Song.
   </t>
  </section>
  <section anchor="appendix" title="Appendix">
   <t>
    This appendix is informative. In case of any discrepancy, the body
    of the document is authoritative.
   </t>
   <t>
    For reference, the following table lists opcodes in order by value.
   </t>
   <table>
    <thead>
     <tr>
      <th>opcode</th>
      <th>src</th>
      <th>imm</th>
      <th>description</th>
      <th>reference</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (additional immediate value)
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x04
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst + (u32)imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x05
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x07
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst += imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x0c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst + (u32)src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x0f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst += src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x14
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst - (u32)imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x15
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst == imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x16
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst == imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x17
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst -= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = imm64
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = map_by_fd(imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x2
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = mva(map_by_fd(imm)) + next_imm
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = variable_addr(imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x4
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = code_addr(imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x5
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = map_by_idx(imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x6
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = mva(map_by_idx(imm)) + next_imm
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst - (u32)src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst == src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst == (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst -= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x24
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst * imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x25
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &gt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x26
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x27
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst *= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x28
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst * src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst &gt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt; (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst *= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x30
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x34
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((imm != 0) ? (dst / imm) : 0)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x35
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &gt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x36
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x37
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (imm != 0) ? (dst / imm) : 0
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x38
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((imm != 0) ? (dst / src) : 0)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst &gt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt;= (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (src !+ 0) ? (dst / src) : 0
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x44
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst | imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x45
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &amp; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x46
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &amp; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x47
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst |= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x48
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst | src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst &amp; src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &amp; (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst |= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x50
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x54
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &amp; imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x55
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst != imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x56
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst != imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x57
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst &amp;= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x58
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &amp; src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst != src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst != (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst &amp;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x61
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = *(u32 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x62
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u32 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x63
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        *(u32 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x64
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &lt;&lt; imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x65
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&gt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x66
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt; (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x67
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst &lt;&lt;= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x69
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = *(u16 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6a
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u16 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6b
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        *(u16 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &lt;&lt; src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst s&gt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt; (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst &lt;&lt;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x71
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = *(u8 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x72
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u8 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x73
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        *(u8 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x74
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &gt;&gt; imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x75
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&gt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x76
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt;= (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x77
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst &gt;&gt;= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x79
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = *(u64 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7a
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u64 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7b
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        *(u64 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &gt;&gt; src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst s&gt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt;= (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst &gt;&gt;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x84
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)-dst
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x85
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        call platform-agnostic helper function imm
       </t>
      </td>
      <td>
       <t>
        <xref target="helper-functions">Helper functions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x85
       </t>
      </td>
      <td>
       <t>
        0x1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        call PC += offset
       </t>
      </td>
      <td>
       <t>
        <xref target="program-local-functions">Program-local functions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x85
       </t>
      </td>
      <td>
       <t>
        0x2
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        call platform-specific helper function imm
       </t>
      </td>
      <td>
       <t>
        <xref target="helper-functions">Helper functions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x87
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = -dst
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x94
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((imm != 0) ? (dst % imm) : dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x95
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        return
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x97
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (imm != 0) ? (dst % imm) : dst
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x9c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((src != 0) ? (dst % src) : dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x9f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (src != 0) ? (dst % src) : dst
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst ^ imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &lt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst ^= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xac
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst ^ src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xad
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst &lt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xae
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt; (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xaf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst ^= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xb4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32) imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xb5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &lt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xb7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbc
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32) src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbd
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst &lt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbe
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt;= (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        lock *(u32 *)(dst + offset) += src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x01
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    *(u32 *)(dst + offset) += src
    src = *(u32 *)(dst + offset)
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        *(u32 *)(dst + offset) |= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x41
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    *(u32 *)(dst + offset) |= src
    src = *(u32 *)(dst + offset)
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x50
       </t>
      </td>
      <td>
       <t>
        *(u32 *)(dst + offset) &amp;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x51
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    *(u32 *)(dst + offset) &amp;= src
    src = *(u32 *)(dst + offset)
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa0
       </t>
      </td>
      <td>
       <t>
        *(u32 *)(dst + offset) ^= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa1
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    *(u32 *)(dst + offset) ^= src
    src = *(u32 *)(dst + offset)
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xe1
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    temp = *(u32 *)(dst + offset)
    *(u32 *)(dst + offset) = src
    src = temp
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xf1
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    temp = *(u32 *)(dst + offset)
    if *(u32)(dst + offset) == R0
       *(u32)(dst + offset) = src
    R0 = temp
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst s&gt;&gt; imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&lt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt; (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst s&gt;&gt;= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xcc
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst s&gt;&gt; src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xcd
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst s&lt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xce
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt; (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xcf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst s&gt;&gt;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x10
       </t>
      </td>
      <td>
       <t>
        dst = htole16(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        dst = htole32(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        dst = htole64(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&lt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt;= (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        lock *(u64 *)(dst + offset) += src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x01
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    *(u64 *)(dst + offset) += src
    src = *(u64 *)(dst + offset)
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        *(u64 *)(dst + offset) |= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x41
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    *(u64 *)(dst + offset) |= src
    lock src = *(u64 *)(dst + offset)
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x50
       </t>
      </td>
      <td>
       <t>
        *(u64 *)(dst + offset) &amp;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x51
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    *(u64 *)(dst + offset) &amp;= src
    src = *(u64 *)(dst + offset)
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa0
       </t>
      </td>
      <td>
       <t>
        *(u64 *)(dst + offset) ^= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa1
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    *(u64 *)(dst + offset) ^= src
    src = *(u64 *)(dst + offset)
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xe1
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    temp = *(u64 *)(dst + offset)
    *(u64 *)(dst + offset) = src
    src = temp
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xf1
       </t>
      </td>
      <td>
       <t>
        lock:
       </t>
       <artwork>
    temp = *(u64 *)(dst + offset)
    if *(u64)(dst + offset) == R0
       *(u64)(dst + offset) = src
    R0 = temp
       </artwork>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdc
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x10
       </t>
      </td>
      <td>
       <t>
        dst = htobe16(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdc
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        dst = htobe32(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdc
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        dst = htobe64(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdd
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst s&lt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xde
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt;= (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
    </tbody>
   </table>
  </section>
 </middle>
 <back>
 <references><name>Normative References</name>
  <reference anchor="RFC8126">
   <front>
    <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
    <author></author>
   </front>
   <seriesInfo name='RFC' value='8126'/>
  </reference>
 </references>
 </back>
</rfc>
