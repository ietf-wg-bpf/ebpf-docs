<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
  <!-- generated by https://github.com/dthaler/rst2rfcxml version 0.1 -->

<!DOCTYPE rfc [
]>

<?rfc rfcedstyle="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-thaler-bpf-instruction-set-00" category="std" submissionType="IETF">

 <front>
  <title abbrev="eBPF ISA">
eBPF Instruction Set Specification, v1.0
  </title>
  <author fullname="Dave Thaler" initials="D." surname="Thaler" role="editor">
   <address>
    <postal>
    <city>Redmond</city>
    <region>WA</region>
    </postal>
    <email>dthaler@microsoft.com</email>
   </address>
  </author>
  <abstract>
   <t>
    This document specifies version 1.0 of the eBPF instruction set.
   </t>
   <t>
    The eBPF instruction set consists of eleven 64 bit registers, a program counter,
    and an implementation-specific amount (e.g., 512 bytes) of stack space.
   </t>
  </abstract>
 </front>
 <middle>
  <section anchor="documentation-conventions" title="Documentation conventions">
   <t>
    For brevity, this document uses the type notion "u64", "u32", etc.
    to mean an unsigned integer whose width is the specified number of bits,
    and "s32", etc. to mean a signed integer of the specified number of bits.
   </t>
  </section>
  <section anchor="registers-and-calling-convention" title="Registers and calling convention">
   <t>
    eBPF has 10 general purpose registers and a read-only frame pointer register,
    all of which are 64-bits wide.
   </t>
   <t>
    The eBPF calling convention is defined as:
   </t>
   <ul>
    <li>
     R0: return value from function calls, and exit value for eBPF programs
    </li>
    <li>
     R1 - R5: arguments for function calls
    </li>
    <li>
     R6 - R9: callee saved registers that function calls will preserve
    </li>
    <li>
     R10: read-only frame pointer to access stack
    </li>
   </ul>
   <t>
    Registers R0 - R5 are caller-saved registers, meaning the BPF program needs to either
    spill them to the BPF stack or move them to callee saved registers if these
    arguments are to be reused across multiple function calls. Spilling means
    that the value in the register is moved to the BPF stack. The reverse operation
    of moving the variable from the BPF stack to the register is called filling.
    The reason for spilling/filling is due to the limited number of registers.
   </t>
   <t>
    Upon entering execution of an eBPF program, registers R1 - R5 initially can contain
    the input arguments for the program (similar to the argc/argv pair for a typical C program).
    The actual number of registers used, and their meaning, is defined by the program type;
    for example, a networking program might have an argument that includes network packet data
    and/or metadata.
   </t>
  </section>
  <section anchor="instruction-encoding" title="Instruction encoding">
   <t>
    An eBPF program is a sequence of instructions.
   </t>
   <t>
    eBPF has two instruction encodings:
   </t>
   <ul>
    <li>
     the basic instruction encoding, which uses 64 bits to encode an instruction
    </li>
    <li>
     the wide instruction encoding, which appends a second 64-bit immediate (i.e.,
     constant) value after the basic instruction for a total of 128 bits.
    </li>
   </ul>
   <t>
    The basic instruction encoding is as follows, where MSB and LSB mean the most significant
    bits and least significant bits, respectively:
   </t>
   <table><thead><tr>
     <th>32 bits (MSB)</th>
     <th>16 bits</th>
     <th>4 bits</th>
     <th>4 bits</th>
     <th>8 bits (LSB)</th>
    </tr></thead>
    <tbody>
     <tr>
      <td>imm</td>
      <td>offset</td>
      <td>src</td>
      <td>dst</td>
      <td>opcode</td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt>
     imm
    </dt>
    <dd>
     signed integer immediate value
    </dd>
    <dt>
     offset
    </dt>
    <dd>
     signed integer offset used with pointer arithmetic
    </dd>
    <dt>
     src
    </dt>
    <dd>
     the source register number (0-10), except where otherwise specified
     (<xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref> reuse this field for other purposes)
    </dd>
    <dt>
     dst
    </dt>
    <dd>
     destination register number (0-10)
    </dd>
    <dt>
     opcode
    </dt>
    <dd>
     operation to perform
    </dd>
   </dl>
   <t>
    Note that most instructions do not use all of the fields.
    Unused fields must be set to zero.
   </t>
   <t>
    As discussed below in <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>, a 64-bit immediate
    instruction uses a 64-bit immediate value that is constructed as follows.
    The 64 bits following the basic instruction contain a pseudo instruction
    using the same format but with opcode, dst, src, and offset all set to zero,
    and imm containing the high 32 bits of the immediate value.
   </t>
   <table><thead><tr>
     <th>64 bits (MSB)</th>
     <th>64 bits (LSB)</th>
    </tr></thead>
    <tbody>
     <tr>
      <td>basic instruction</td>
      <td>pseudo instruction</td>
     </tr>
    </tbody>
   </table>
   <t>
    Thus the 64-bit immediate value is constructed as follows:
   </t>
   <blockquote>    imm64 = (next_imm &lt;&lt; 32) | imm
   </blockquote>
   <t>
    where 'next_imm' refers to the imm value of the pseudo instruction
    following the basic instruction.
   </t>
   <t>
    In the remainder of this document 'src' and 'dst' refer to the values of the source
    and destination registers, respectively, rather than the register number.
   </t>
   <section anchor="instruction-classes" title="Instruction classes">
    <t>
     The encoding of the 'opcode' field varies and can be determined from
     the three least significant bits (LSB) of the 'opcode' field which holds
     the "instruction class", as follows:
    </t>
    <table><thead><tr>
      <th>class</th>
      <th>value</th>
      <th>description</th>
      <th>reference</th>
     </tr></thead>
     <tbody>
      <tr>
       <td>BPF_LD</td>
       <td>0x00</td>
       <td>non-standard load operations</td>
       <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
      </tr>
      <tr>
       <td>BPF_LDX</td>
       <td>0x01</td>
       <td>load into register operations</td>
       <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
      </tr>
      <tr>
       <td>BPF_ST</td>
       <td>0x02</td>
       <td>store from immediate operations</td>
       <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
      </tr>
      <tr>
       <td>BPF_STX</td>
       <td>0x03</td>
       <td>store from register operations</td>
       <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
      </tr>
      <tr>
       <td>BPF_ALU</td>
       <td>0x04</td>
       <td>32-bit arithmetic operations</td>
       <td><xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref></td>
      </tr>
      <tr>
       <td>BPF_JMP</td>
       <td>0x05</td>
       <td>64-bit jump operations</td>
       <td><xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref></td>
      </tr>
      <tr>
       <td>BPF_JMP32</td>
       <td>0x06</td>
       <td>32-bit jump operations</td>
       <td><xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref></td>
      </tr>
      <tr>
       <td>BPF_ALU64</td>
       <td>0x07</td>
       <td>64-bit arithmetic operations</td>
       <td><xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref></td>
      </tr>
     </tbody>
    </table>
   </section>
  </section>
  <section anchor="arithmetic-and-jump-instructions" title="Arithmetic and jump instructions">
   <t>
    For arithmetic and jump instructions (<tt>BPF_ALU</tt>, <tt>BPF_ALU64</tt>, <tt>BPF_JMP</tt> and
    <tt>BPF_JMP32</tt>), the 8-bit 'opcode' field is divided into three parts:
   </t>
   <table><thead><tr>
     <th>4 bits (MSB)</th>
     <th>1 bit</th>
     <th>3 bits (LSB)</th>
    </tr></thead>
    <tbody>
     <tr>
      <td>code</td>
      <td>source</td>
      <td>instruction class</td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt>
     code
    </dt>
    <dd>
     the operation code, whose meaning varies by instruction class
    </dd>
    <dt>
     source
    </dt>
    <dd>
     the source operand location, which unless otherwise specified is one of:
    </dd>
   </dl>
   <table><thead><tr>
     <th>source</th>
     <th>value</th>
     <th>description</th>
    </tr></thead>
    <tbody>
     <tr>
      <td>BPF_K</td>
      <td>0x00</td>
      <td>use 32-bit 'imm' value as source operand</td>
     </tr>
     <tr>
      <td>BPF_X</td>
      <td>0x08</td>
      <td>use 'src' register value as source operand</td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt>
     instruction class
    </dt>
    <dd>
     the instruction class (see <xref target="instruction-classes">Instruction classes</xref>)
    </dd>
   </dl>
   <section anchor="arithmetic-instructions" title="Arithmetic instructions">
    <t>
     Instruction class <tt>BPF_ALU</tt> uses 32-bit wide operands (zeroing the upper 32 bits
     of the destination register) while <tt>BPF_ALU64</tt> uses 64-bit wide operands for
     otherwise identical operations.
    </t>
    <t>
     The 4-bit 'code' field encodes the operation as follows:
    </t>
    <table><thead><tr>
      <th>code</th>
      <th>value</th>
      <th>description</th>
     </tr></thead>
     <tbody>
      <tr>
       <td>BPF_ADD</td>
       <td>0x00</td>
       <td>dst += src</td>
      </tr>
      <tr>
       <td>BPF_SUB</td>
       <td>0x10</td>
       <td>dst -= src</td>
      </tr>
      <tr>
       <td>BPF_MUL</td>
       <td>0x20</td>
       <td>dst *= src</td>
      </tr>
      <tr>
       <td>BPF_DIV</td>
       <td>0x30</td>
       <td>dst = (src != 0) ? (dst / src) : 0</td>
      </tr>
      <tr>
       <td>BPF_OR</td>
       <td>0x40</td>
       <td>dst |= src</td>
      </tr>
      <tr>
       <td>BPF_AND</td>
       <td>0x50</td>
       <td>dst &amp;= src</td>
      </tr>
      <tr>
       <td>BPF_LSH</td>
       <td>0x60</td>
       <td>dst &lt;&lt;= src</td>
      </tr>
      <tr>
       <td>BPF_RSH</td>
       <td>0x70</td>
       <td>dst &gt;&gt;= src</td>
      </tr>
      <tr>
       <td>BPF_NEG</td>
       <td>0x80</td>
       <td>dst = ~src</td>
      </tr>
      <tr>
       <td>BPF_MOD</td>
       <td>0x90</td>
       <td>dst = (src != 0) ? (dst % src) : dst</td>
      </tr>
      <tr>
       <td>BPF_XOR</td>
       <td>0xa0</td>
       <td>dst ^= src</td>
      </tr>
      <tr>
       <td>BPF_MOV</td>
       <td>0xb0</td>
       <td>dst = src</td>
      </tr>
      <tr>
       <td>BPF_ARSH</td>
       <td>0xc0</td>
       <td>sign extending shift right</td>
      </tr>
      <tr>
       <td>BPF_END</td>
       <td>0xd0</td>
       <td>byte swap operations (see <xref target="byte-swap-instructions">Byte swap instructions</xref> below)</td>
      </tr>
     </tbody>
    </table>
    <t>
     Underflow and overflow are allowed during arithmetic operations, meaning
     the 64-bit or 32-bit value will wrap. If eBPF program execution would
     result in division by zero, the destination register is instead set to zero.
     If execution would result in modulo by zero, for <tt>BPF_ALU64</tt> the value of
     the destination register is unchanged whereas for <tt>BPF_ALU</tt> the upper
     32 bits of the destination register are zeroed.
    </t>
    <t>
     Examples:
    </t>
    <t>
     <tt>BPF_ADD | BPF_X | BPF_ALU</tt> (0x0c) means:
    </t>
    <blockquote>     dst = (u32) ((u32) dst + (u32) src)
    </blockquote>
    <t>
     where '(u32)' indicates that the upper 32 bits are zeroed.
    </t>
    <t>
     <tt>BPF_ADD | BPF_X | BPF_ALU64</tt> (0x0f) means:
    </t>
    <blockquote>     dst = dst + src
    </blockquote>
    <t>
     <tt>BPF_XOR | BPF_K | BPF_ALU</tt> (0xa4) means:
    </t>
    <blockquote>     dst = (u32) dst ^ (u32) imm32
    </blockquote>
    <t>
     <tt>BPF_XOR | BPF_K | BPF_ALU64</tt> (0xa7) means:
    </t>
    <blockquote>     dst = dst ^ imm32
    </blockquote>
    <t>
     Also note that the division and modulo operations are unsigned. Thus, for
     <tt>BPF_ALU</tt>, 'imm' is first interpreted as an unsigned 32-bit value, whereas
     for <tt>BPF_ALU64</tt>, 'imm' is first sign extended to 64 bits and the result
     interpreted as an unsigned 64-bit value. There are no instructions for
     signed division or modulo.
    </t>
    <section anchor="byte-swap-instructions" title="Byte swap instructions">
     <t>
      The byte swap instructions use an instruction class of <tt>BPF_ALU</tt> and a 4-bit
      'code' field of <tt>BPF_END</tt>.
     </t>
     <t>
      The byte swap instructions operate on the destination register
      only and do not use a separate source register or immediate value.
     </t>
     <t>
      Byte swap instructions use the 1-bit 'source' field in the 'opcode' field
      as follows.  Instead of indicating the source operator, it is instead
      used to select what byte order the operation converts from or to:
     </t>
     <table><thead><tr>
       <th>source</th>
       <th>value</th>
       <th>description</th>
      </tr></thead>
      <tbody>
       <tr>
        <td>BPF_TO_LE</td>
        <td>0x00</td>
        <td>convert between host byte order and little endian</td>
       </tr>
       <tr>
        <td>BPF_TO_BE</td>
        <td>0x08</td>
        <td>convert between host byte order and big endian</td>
       </tr>
      </tbody>
     </table>
     <t>
      The 'imm' field encodes the width of the swap operations.  The following widths
      are supported: 16, 32 and 64. The following table summarizes the resulting
      possibilities:
     </t>
     <table><thead><tr>
       <th>opcode construction</th>
       <th>opcode</th>
       <th>imm</th>
       <th>mnemonic</th>
       <th>pseudocode</th>
      </tr></thead>
      <tbody>
       <tr>
        <td>BPF_END | BPF_TO_LE | BPF_ALU</td>
        <td>0xd4</td>
        <td>16</td>
        <td>le16 dst</td>
        <td>dst = htole16(dst)</td>
       </tr>
       <tr>
        <td>BPF_END | BPF_TO_LE | BPF_ALU</td>
        <td>0xd4</td>
        <td>32</td>
        <td>le32 dst</td>
        <td>dst = htole32(dst)</td>
       </tr>
       <tr>
        <td>BPF_END | BPF_TO_LE | BPF_ALU</td>
        <td>0xd4</td>
        <td>64</td>
        <td>le64 dst</td>
        <td>dst = htole64(dst)</td>
       </tr>
       <tr>
        <td>BPF_END | BPF_TO_BE | BPF_ALU</td>
        <td>0xdc</td>
        <td>16</td>
        <td>be16 dst</td>
        <td>dst = htobe16(dst)</td>
       </tr>
       <tr>
        <td>BPF_END | BPF_TO_BE | BPF_ALU</td>
        <td>0xdc</td>
        <td>32</td>
        <td>be32 dst</td>
        <td>dst = htobe32(dst)</td>
       </tr>
       <tr>
        <td>BPF_END | BPF_TO_BE | BPF_ALU</td>
        <td>0xdc</td>
        <td>64</td>
        <td>be64 dst</td>
        <td>dst = htobe64(dst)</td>
       </tr>
      </tbody>
     </table>
     <t>
      where
     </t>
     <ul>
      <li>
       mnenomic indicates a short form that might be displayed by some tools such as disassemblers
      </li>
      <li>
       'htoleNN()' indicates converting a NN-bit value from host byte order to little-endian byte order
      </li>
      <li>
       'htobeNN()' indicates converting a NN-bit value from host byte order to big-endian byte order
      </li>
     </ul>
    </section>
   </section>
   <section anchor="jump-instructions" title="Jump instructions">
    <t>
     Instruction class <tt>BPF_JMP32</tt> uses 32-bit wide operands while <tt>BPF_JMP</tt> uses 64-bit wide operands for
     otherwise identical operations.
    </t>
    <t>
     The 4-bit 'code' field encodes the operation as below, where PC is the program counter:
    </t>
    <table><thead><tr>
      <th>code</th>
      <th>value</th>
      <th>src</th>
      <th>description</th>
      <th>notes</th>
     </tr></thead>
     <tbody>
      <tr>
       <td>BPF_JA</td>
       <td>0x0</td>
       <td>0x0</td>
       <td>PC += offset</td>
       <td>BPF_JMP only</td>
      </tr>
      <tr>
       <td>BPF_JEQ</td>
       <td>0x1</td>
       <td>any</td>
       <td>PC += offset if dst == src</td>
       <td></td>
      </tr>
      <tr>
       <td>BPF_JGT</td>
       <td>0x2</td>
       <td>any</td>
       <td>PC += offset if dst &gt; src</td>
       <td>unsigned</td>
      </tr>
      <tr>
       <td>BPF_JGE</td>
       <td>0x3</td>
       <td>any</td>
       <td>PC += offset if dst &gt;= src</td>
       <td>unsigned</td>
      </tr>
      <tr>
       <td>BPF_JSET</td>
       <td>0x4</td>
       <td>any</td>
       <td>PC += offset if dst &amp; src</td>
       <td></td>
      </tr>
      <tr>
       <td>BPF_JNE</td>
       <td>0x5</td>
       <td>any</td>
       <td>PC += offset if dst != src</td>
       <td></td>
      </tr>
      <tr>
       <td>BPF_JSGT</td>
       <td>0x6</td>
       <td>any</td>
       <td>PC += offset if dst &gt; src</td>
       <td>signed</td>
      </tr>
      <tr>
       <td>BPF_JSGE</td>
       <td>0x7</td>
       <td>any</td>
       <td>PC += offset if dst &gt;= src</td>
       <td>signed</td>
      </tr>
      <tr>
       <td>BPF_CALL</td>
       <td>0x8</td>
       <td>0x0</td>
       <td>call helper function imm</td>
       <td>see <xref target="helper-functions">Helper functions</xref></td>
      </tr>
      <tr>
       <td>BPF_CALL</td>
       <td>0x8</td>
       <td>0x1</td>
       <td>call PC += offset</td>
       <td>see <xref target="ebpf-functions">eBPF functions</xref></td>
      </tr>
      <tr>
       <td>BPF_CALL</td>
       <td>0x8</td>
       <td>0x2</td>
       <td>call runtime function imm</td>
       <td>see <xref target="runtime-functions">Runtime functions</xref></td>
      </tr>
      <tr>
       <td>BPF_EXIT</td>
       <td>0x9</td>
       <td>0x0</td>
       <td>return</td>
       <td>BPF_JMP only</td>
      </tr>
      <tr>
       <td>BPF_JLT</td>
       <td>0xa</td>
       <td>any</td>
       <td>PC += offset if dst &lt; src</td>
       <td>unsigned</td>
      </tr>
      <tr>
       <td>BPF_JLE</td>
       <td>0xb</td>
       <td>any</td>
       <td>PC += offset if dst &lt;= src</td>
       <td>unsigned</td>
      </tr>
      <tr>
       <td>BPF_JSLT</td>
       <td>0xc</td>
       <td>any</td>
       <td>PC += offset if dst &lt; src</td>
       <td>signed</td>
      </tr>
      <tr>
       <td>BPF_JSLE</td>
       <td>0xd</td>
       <td>any</td>
       <td>PC += offset if dst &lt;= src</td>
       <td>signed</td>
      </tr>
     </tbody>
    </table>
    <section anchor="helper-functions" title="Helper functions">
     <t>
      Helper functions are a concept whereby BPF programs can call into a
      set of function calls exposed by the eBPF runtime.  Each helper
      function is identified by an integer used in a <tt>BPF_CALL</tt> instruction.
      The available helper functions may differ for each eBPF program type.
     </t>
     <t>
      Conceptually, each helper function is implemented with a commonly shared function
      signature defined as:
     </t>
     <blockquote>      u64 function(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)
     </blockquote>
     <t>
      In actuality, each helper function is defined as taking between 0 and 5 arguments,
      with the remaining registers being ignored.  The definition of a helper function
      is responsible for specifying the type (e.g., integer, pointer, etc.) of the value returned,
      the number of arguments, and the type of each argument.
     </t>
     <t>
      Note that <tt>BPF_CALL | BPF_X | BPF_JMP</tt> (0x8d), where the helper function integer
      would be read from a specified register, is reserved and currently not permitted.
     </t>
    </section>
    <section anchor="runtime-functions" title="Runtime functions">
     <t>
      Runtime functions are like helper functions except that they are not specific
      to eBPF programs.  They use a different numbering space from helper functions,
      but otherwise the same considerations apply.
     </t>
    </section>
    <section anchor="ebpf-functions" title="eBPF functions">
     <t>
      eBPF functions are functions exposed by the same eBPF program as the caller,
      and are referenced by offset from the call instruction, similar to <tt>BPF_JA</tt>.
      A <tt>BPF_EXIT</tt> within the eBPF function will return to the caller.
     </t>
    </section>
   </section>
  </section>
  <section anchor="load-and-store-instructions" title="Load and store instructions">
   <t>
    For load and store instructions (<tt>BPF_LD</tt>, <tt>BPF_LDX</tt>, <tt>BPF_ST</tt>, and <tt>BPF_STX</tt>), the
    8-bit 'opcode' field is divided as:
   </t>
   <table><thead><tr>
     <th>3 bits (MSB)</th>
     <th>2 bits</th>
     <th>3 bits (LSB)</th>
    </tr></thead>
    <tbody>
     <tr>
      <td>mode</td>
      <td>size</td>
      <td>instruction class</td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt>
     mode
    </dt>
    <dd>
     one of:
    </dd>
   </dl>
   <table><thead><tr>
     <th>mode modifier</th>
     <th>value</th>
     <th>description</th>
     <th>reference</th>
    </tr></thead>
    <tbody>
     <tr>
      <td>BPF_IMM</td>
      <td>0x00</td>
      <td>64-bit immediate instructions</td>
      <td><xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref></td>
     </tr>
     <tr>
      <td>BPF_ABS</td>
      <td>0x20</td>
      <td>legacy BPF packet access (absolute)</td>
      <td><xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref></td>
     </tr>
     <tr>
      <td>BPF_IND</td>
      <td>0x40</td>
      <td>legacy BPF packet access (indirect)</td>
      <td><xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref></td>
     </tr>
     <tr>
      <td>BPF_MEM</td>
      <td>0x60</td>
      <td>regular load and store operations</td>
      <td><xref target="regular-load-and-store-operations">Regular load and store operations</xref></td>
     </tr>
     <tr>
      <td>BPF_ATOMIC</td>
      <td>0xc0</td>
      <td>atomic operations</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt>
     size
    </dt>
    <dd>
     one of:
    </dd>
   </dl>
   <table><thead><tr>
     <th>size modifier</th>
     <th>value</th>
     <th>description</th>
    </tr></thead>
    <tbody>
     <tr>
      <td>BPF_W</td>
      <td>0x00</td>
      <td>word        (4 bytes)</td>
     </tr>
     <tr>
      <td>BPF_H</td>
      <td>0x08</td>
      <td>half word   (2 bytes)</td>
     </tr>
     <tr>
      <td>BPF_B</td>
      <td>0x10</td>
      <td>byte</td>
     </tr>
     <tr>
      <td>BPF_DW</td>
      <td>0x18</td>
      <td>double word (8 bytes)</td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt>
     instruction class
    </dt>
    <dd>
     the instruction class (see <xref target="instruction-classes">Instruction classes</xref>)
    </dd>
   </dl>
   <section anchor="regular-load-and-store-operations" title="Regular load and store operations">
    <t>
     The <tt>BPF_MEM</tt> mode modifier is used to encode regular load and store
     instructions that transfer data between a register and memory.
    </t>
    <t>
     <tt>BPF_MEM | &lt;size&gt; | BPF_STX</tt> means:
    </t>
    <blockquote>     *(size *) (dst + offset) = src_reg
    </blockquote>
    <t>
     <tt>BPF_MEM | &lt;size&gt; | BPF_ST</tt> means:
    </t>
    <blockquote>     *(size *) (dst + offset) = imm32
    </blockquote>
    <t>
     <tt>BPF_MEM | &lt;size&gt; | BPF_LDX</tt> means:
    </t>
    <blockquote>     dst = *(size *) (src + offset)
    </blockquote>
    <t>
     where size is one of: <tt>BPF_B</tt>, <tt>BPF_H</tt>, <tt>BPF_W</tt>, or <tt>BPF_DW</tt>.
    </t>
   </section>
   <section anchor="atomic-operations" title="Atomic operations">
    <t>
     Atomic operations are operations that operate on memory and can not be
     interrupted or corrupted by other access to the same memory region
     by other eBPF programs or means outside of this specification.
    </t>
    <t>
     All atomic operations supported by eBPF are encoded as store operations
     that use the <tt>BPF_ATOMIC</tt> mode modifier as follows:
    </t>
    <ul>
     <li>
      <tt>BPF_ATOMIC | BPF_W | BPF_STX</tt> (0xc3) for 32-bit operations
     </li>
     <li>
      <tt>BPF_ATOMIC | BPF_DW | BPF_STX</tt> (0xdb) for 64-bit operations
     </li>
    </ul>
    <t>
     Note that 8-bit (<tt>BPF_B</tt>) and 16-bit (<tt>BPF_H</tt>) wide atomic operations are not supported,
     nor is <tt>BPF_ATOMIC | &lt;size&gt; | BPF_ST</tt>.
    </t>
    <t>
     The 'imm' field is used to encode the actual atomic operation.
     Simple atomic operation use a subset of the values defined to encode
     arithmetic operations in the 'imm' field to encode the atomic operation:
    </t>
    <table><thead><tr>
      <th>imm</th>
      <th>value</th>
      <th>description</th>
     </tr></thead>
     <tbody>
      <tr>
       <td>BPF_ADD</td>
       <td>0x00</td>
       <td>atomic add</td>
      </tr>
      <tr>
       <td>BPF_OR</td>
       <td>0x40</td>
       <td>atomic or</td>
      </tr>
      <tr>
       <td>BPF_AND</td>
       <td>0x50</td>
       <td>atomic and</td>
      </tr>
      <tr>
       <td>BPF_XOR</td>
       <td>0xa0</td>
       <td>atomic xor</td>
      </tr>
     </tbody>
    </table>
    <t>
     <tt>BPF_ATOMIC | BPF_W  | BPF_STX</tt> (0xc3) with 'imm' = BPF_ADD means:
    </t>
    <blockquote>     *(u32 *)(dst + offset) += src
    </blockquote>
    <t>
     <tt>BPF_ATOMIC | BPF_DW | BPF_STX</tt> (0xdb) with 'imm' = BPF ADD means:
    </t>
    <blockquote>     *(u64 *)(dst + offset) += src
    </blockquote>
    <t>
     In addition to the simple atomic operations above, there also is a modifier and
     two complex atomic operations:
    </t>
    <table><thead><tr>
      <th>imm</th>
      <th>value</th>
      <th>description</th>
     </tr></thead>
     <tbody>
      <tr>
       <td>BPF_FETCH</td>
       <td>0x01</td>
       <td>modifier: return old value</td>
      </tr>
      <tr>
       <td>BPF_XCHG</td>
       <td>0xe0 | BPF_FETCH</td>
       <td>atomic exchange</td>
      </tr>
      <tr>
       <td>BPF_CMPXCHG</td>
       <td>0xf0 | BPF_FETCH</td>
       <td>atomic compare and exchange</td>
      </tr>
     </tbody>
    </table>
    <t>
     The <tt>BPF_FETCH</tt> modifier is optional for simple atomic operations, and
     always set for the complex atomic operations.  If the <tt>BPF_FETCH</tt> flag
     is set, then the operation also overwrites <tt>src</tt> with the value that
     was in memory before it was modified.
    </t>
    <t>
     The <tt>BPF_XCHG</tt> operation atomically exchanges <tt>src</tt> with the value
     addressed by <tt>dst + offset</tt>.
    </t>
    <t>
     The <tt>BPF_CMPXCHG</tt> operation atomically compares the value addressed by
     <tt>dst + offset</tt> with <tt>R0</tt>. If they match, the value addressed by
     <tt>dst + offset</tt> is replaced with <tt>src</tt>. In either case, the
     value that was at <tt>dst + offset</tt> before the operation is zero-extended
     and loaded back to <tt>R0</tt>.
    </t>
   </section>
   <section anchor="-4-bit-immediate-instructions" title="64-bit immediate instructions">
    <t>
     Instructions with the <tt>BPF_IMM</tt> 'mode' modifier use the wide instruction
     encoding defined in <xref target="instruction-encoding">Instruction encoding</xref>, and use the 'src' field of the
     basic instruction to hold an opcode subtype.
    </t>
    <t>
     The following instructions are defined, and use additional concepts defined below:
    </t>
    <table><thead><tr>
      <th>opcode construction</th>
      <th>opcode</th>
      <th>src</th>
      <th>pseudocode</th>
      <th>imm type</th>
      <th>dst type</th>
     </tr></thead>
     <tbody>
      <tr>
       <td>BPF_IMM | BPF_DW | BPF_LD</td>
       <td>0x18</td>
       <td>0x0</td>
       <td>dst = imm64</td>
       <td>integer</td>
       <td>integer</td>
      </tr>
      <tr>
       <td>BPF_IMM | BPF_DW | BPF_LD</td>
       <td>0x18</td>
       <td>0x1</td>
       <td>dst = map_by_fd(imm)</td>
       <td>map fd</td>
       <td>map</td>
      </tr>
      <tr>
       <td>BPF_IMM | BPF_DW | BPF_LD</td>
       <td>0x18</td>
       <td>0x2</td>
       <td>dst = mva(map_by_fd(imm)) + next_imm</td>
       <td>map fd</td>
       <td>data pointer</td>
      </tr>
      <tr>
       <td>BPF_IMM | BPF_DW | BPF_LD</td>
       <td>0x18</td>
       <td>0x3</td>
       <td>dst = variable_addr(imm)</td>
       <td>variable id</td>
       <td>data pointer</td>
      </tr>
      <tr>
       <td>BPF_IMM | BPF_DW | BPF_LD</td>
       <td>0x18</td>
       <td>0x4</td>
       <td>dst = code_addr(imm)</td>
       <td>integer</td>
       <td>code pointer</td>
      </tr>
      <tr>
       <td>BPF_IMM | BPF_DW | BPF_LD</td>
       <td>0x18</td>
       <td>0x5</td>
       <td>dst = map_by_idx(imm)</td>
       <td>map index</td>
       <td>map</td>
      </tr>
      <tr>
       <td>BPF_IMM | BPF_DW | BPF_LD</td>
       <td>0x18</td>
       <td>0x6</td>
       <td>dst = mva(map_by_idx(imm)) + next_imm</td>
       <td>map index</td>
       <td>data pointer</td>
      </tr>
     </tbody>
    </table>
    <t>
     where
    </t>
    <ul>
     <li>
      map_by_fd(fd) means to convert a 32-bit POSIX file descriptor into an address of a map object (see <xref target="map-objects">Map objects</xref>)
     </li>
     <li>
      map_by_index(index) means to convert a 32-bit index into an address of a map object
     </li>
     <li>
      mva(map) gets the address of the first value in a given map object
     </li>
     <li>
      variable_addr(id) gets the address of a variable (see <xref target="variables">Variables</xref>) with a given id
     </li>
     <li>
      code_addr(offset) gets the address of the instruction at a specified relative offset in units of 64-bit blocks
     </li>
     <li>
      the 'imm type' can be used by disassemblers for display
     </li>
     <li>
      the 'dst type' can be used for verification and JIT compilation purposes
     </li>
    </ul>
    <section anchor="map-objects" title="Map objects">
     <t>
      Maps are shared memory regions accessible by eBPF programs on some platforms, where we use the term "map object"
      to refer to an object containing the data and metadata (e.g., size) about the memory region.
      A map can have various semantics as defined in a separate document, and may or may not have a single
      contiguous memory region, but the 'mva(map)' is currently only defined for maps that do have a single
      contiguous memory region.  Support for maps is optional.
     </t>
     <t>
      Each map object can have a POSIX file descriptor (fd) if supported by the platform,
      where 'map_by_fd(fd)' means to get the map with the specified file descriptor.
      Each eBPF program can also be defined to use a set of maps associated with the program
      at load time, and 'map_by_index(index)' means to get the map with the given index in the set
      associated with the eBPF program containing the instruction.
     </t>
    </section>
    <section anchor="variables" title="Variables">
     <t>
      Variables are memory regions, identified by integer ids, accessible by eBPF programs on
      some platforms.  The 'variable_addr(id)' operation means to get the address of the memory region
      identified by the given id.  Support for such variables is optional.
     </t>
    </section>
   </section>
   <section anchor="legacy-bpf-packet-access-instructions" title="Legacy BPF Packet access instructions">
    <t>
     eBPF previously introduced special instructions for access to packet data that were
     carried over from classic BPF. However, these instructions are
     deprecated and should no longer be used.
    </t>
   </section>
  </section>
  <section anchor="appendix" title="Appendix">
   <t>
    For reference, the following table lists opcodes in order by value.
   </t>
   <table><thead><tr>
     <th>opcode</th>
     <th>src</th>
     <th>imm</th>
     <th>description</th>
     <th>reference</th>
    </tr></thead>
    <tbody>
     <tr>
      <td>0x00</td>
      <td>0x0</td>
      <td>any</td>
      <td>(additional immediate value)</td>
      <td><xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref></td>
     </tr>
     <tr>
      <td>0x04</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32)((u32)dst + (u32)imm)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x05</td>
      <td>0x0</td>
      <td>0x00</td>
      <td>goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x07</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst += imm</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x0c</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32)((u32)dst + (u32)src)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x0f</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst += src</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x14</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32)((u32)dst - (u32)imm)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x15</td>
      <td>0x0</td>
      <td>any</td>
      <td>if dst == imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x16</td>
      <td>0x0</td>
      <td>any</td>
      <td>if (u32)dst == imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x17</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst -= imm</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x18</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = imm64</td>
      <td><xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref></td>
     </tr>
     <tr>
      <td>0x18</td>
      <td>0x1</td>
      <td>any</td>
      <td>dst = map_by_fd(imm)</td>
      <td><xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref></td>
     </tr>
     <tr>
      <td>0x18</td>
      <td>0x2</td>
      <td>any</td>
      <td>dst = mva(map_by_fd(imm)) + next_imm</td>
      <td><xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref></td>
     </tr>
     <tr>
      <td>0x18</td>
      <td>0x3</td>
      <td>any</td>
      <td>dst = variable_addr(imm)</td>
      <td><xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref></td>
     </tr>
     <tr>
      <td>0x18</td>
      <td>0x4</td>
      <td>any</td>
      <td>dst = code_addr(imm)</td>
      <td><xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref></td>
     </tr>
     <tr>
      <td>0x18</td>
      <td>0x5</td>
      <td>any</td>
      <td>dst = map_by_idx(imm)</td>
      <td><xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref></td>
     </tr>
     <tr>
      <td>0x18</td>
      <td>0x6</td>
      <td>any</td>
      <td>dst = mva(map_by_idx(imm)) + next_imm</td>
      <td><xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref></td>
     </tr>
     <tr>
      <td>0x1c</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32)((u32)dst - (u32)src)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x1d</td>
      <td>any</td>
      <td>0x00</td>
      <td>if dst == src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x1e</td>
      <td>any</td>
      <td>0x00</td>
      <td>if (u32)dst == (u32)src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x1f</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst -= src</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x20</td>
      <td>any</td>
      <td>any</td>
      <td>(deprecated, implementation-specific)</td>
      <td><xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref></td>
     </tr>
     <tr>
      <td>0x24</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32)(dst * imm)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x25</td>
      <td>0x0</td>
      <td>any</td>
      <td>if dst &gt; imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x26</td>
      <td>0x0</td>
      <td>any</td>
      <td>if (u32)dst &gt; imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x27</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst *= imm</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x28</td>
      <td>any</td>
      <td>any</td>
      <td>(deprecated, implementation-specific)</td>
      <td><xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref></td>
     </tr>
     <tr>
      <td>0x2c</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32)(dst * src)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x2d</td>
      <td>any</td>
      <td>0x00</td>
      <td>if dst &gt; src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x2e</td>
      <td>any</td>
      <td>0x00</td>
      <td>if (u32)dst &gt; (u32)src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x2f</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst *= src</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x30</td>
      <td>any</td>
      <td>any</td>
      <td>(deprecated, implementation-specific)</td>
      <td><xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref></td>
     </tr>
     <tr>
      <td>0x34</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32)((imm != 0) ? (dst / imm) : 0)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x35</td>
      <td>0x0</td>
      <td>any</td>
      <td>if dst &gt;= imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x36</td>
      <td>0x0</td>
      <td>any</td>
      <td>if (u32)dst &gt;= imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x37</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (imm != 0) ? (dst / imm) : 0</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x38</td>
      <td>any</td>
      <td>any</td>
      <td>(deprecated, implementation-specific)</td>
      <td><xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref></td>
     </tr>
     <tr>
      <td>0x3c</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32)((imm != 0) ? (dst / src) : 0)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x3d</td>
      <td>any</td>
      <td>0x00</td>
      <td>if dst &gt;= src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x3e</td>
      <td>any</td>
      <td>0x00</td>
      <td>if (u32)dst &gt;= (u32)src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x3f</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (src !+ 0) ? (dst / src) : 0</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x40</td>
      <td>any</td>
      <td>any</td>
      <td>(deprecated, implementation-specific)</td>
      <td><xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref></td>
     </tr>
     <tr>
      <td>0x44</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32)(dst | imm)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x45</td>
      <td>0x0</td>
      <td>any</td>
      <td>if dst &amp; imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x46</td>
      <td>0x0</td>
      <td>any</td>
      <td>if (u32)dst &amp; imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x47</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst |= imm</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x48</td>
      <td>any</td>
      <td>any</td>
      <td>(deprecated, implementation-specific)</td>
      <td><xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref></td>
     </tr>
     <tr>
      <td>0x4c</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32)(dst | src)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x4d</td>
      <td>any</td>
      <td>0x00</td>
      <td>if dst &amp; src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x4e</td>
      <td>any</td>
      <td>0x00</td>
      <td>if (u32)dst &amp; (u32)src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x4f</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst |= src</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x50</td>
      <td>any</td>
      <td>any</td>
      <td>(deprecated, implementation-specific)</td>
      <td><xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref></td>
     </tr>
     <tr>
      <td>0x54</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32)(dst &amp; imm)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x55</td>
      <td>0x0</td>
      <td>any</td>
      <td>if dst != imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x56</td>
      <td>0x0</td>
      <td>any</td>
      <td>if (u32)dst != imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x57</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst &amp;= imm</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x58</td>
      <td>any</td>
      <td>any</td>
      <td>(deprecated, implementation-specific)</td>
      <td><xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref></td>
     </tr>
     <tr>
      <td>0x5c</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32)(dst &amp; src)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x5d</td>
      <td>any</td>
      <td>0x00</td>
      <td>if dst != src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x5e</td>
      <td>any</td>
      <td>0x00</td>
      <td>if (u32)dst != (u32)src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x5f</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst &amp;= src</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x61</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = *(u32 *)(src + offset)</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x62</td>
      <td>0x0</td>
      <td>any</td>
      <td>*(u32 *)(dst + offset) = imm</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x63</td>
      <td>any</td>
      <td>0x00</td>
      <td>*(u32 *)(dst + offset) = src</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x64</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32)(dst &lt;&lt; imm)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x65</td>
      <td>0x0</td>
      <td>any</td>
      <td>if dst s&gt; imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x66</td>
      <td>0x0</td>
      <td>any</td>
      <td>if (s32)dst s&gt; (s32)imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x67</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst &lt;&lt;= imm</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x69</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = *(u16 *)(src + offset)</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x6a</td>
      <td>0x0</td>
      <td>any</td>
      <td>*(u16 *)(dst + offset) = imm</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x6b</td>
      <td>any</td>
      <td>0x00</td>
      <td>*(u16 *)(dst + offset) = src</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x6c</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32)(dst &lt;&lt; src)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x6d</td>
      <td>any</td>
      <td>0x00</td>
      <td>if dst s&gt; src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x6e</td>
      <td>any</td>
      <td>0x00</td>
      <td>if (s32)dst s&gt; (s32)src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x6f</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst &lt;&lt;= src</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x71</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = *(u8 *)(src + offset)</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x72</td>
      <td>0x0</td>
      <td>any</td>
      <td>*(u8 *)(dst + offset) = imm</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x73</td>
      <td>any</td>
      <td>0x00</td>
      <td>*(u8 *)(dst + offset) = src</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x74</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32)(dst &gt;&gt; imm)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x75</td>
      <td>0x0</td>
      <td>any</td>
      <td>if dst s&gt;= imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x76</td>
      <td>0x0</td>
      <td>any</td>
      <td>if (s32)dst s&gt;= (s32)imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x77</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst &gt;&gt;= imm</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x79</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = *(u64 *)(src + offset)</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x7a</td>
      <td>0x0</td>
      <td>any</td>
      <td>*(u64 *)(dst + offset) = imm</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x7b</td>
      <td>any</td>
      <td>0x00</td>
      <td>*(u64 *)(dst + offset) = src</td>
      <td><xref target="load-and-store-instructions">Load and store instructions</xref></td>
     </tr>
     <tr>
      <td>0x7c</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32)(dst &gt;&gt; src)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x7d</td>
      <td>any</td>
      <td>0x00</td>
      <td>if dst s&gt;= src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x7e</td>
      <td>any</td>
      <td>0x00</td>
      <td>if (s32)dst s&gt;= (s32)src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x7f</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst &gt;&gt;= src</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x84</td>
      <td>0x0</td>
      <td>0x00</td>
      <td>dst = (u32)-dst</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x85</td>
      <td>0x0</td>
      <td>any</td>
      <td>call helper function imm</td>
      <td><xref target="helper-functions">Helper functions</xref></td>
     </tr>
     <tr>
      <td>0x85</td>
      <td>0x1</td>
      <td>any</td>
      <td>call PC += offset</td>
      <td><xref target="ebpf-functions">eBPF functions</xref></td>
     </tr>
     <tr>
      <td>0x85</td>
      <td>0x2</td>
      <td>any</td>
      <td>call runtime function imm</td>
      <td><xref target="runtime-functions">Runtime functions</xref></td>
     </tr>
     <tr>
      <td>0x87</td>
      <td>0x0</td>
      <td>0x00</td>
      <td>dst = -dst</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x94</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32)((imm != 0) ? (dst % imm) : dst)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x95</td>
      <td>0x0</td>
      <td>0x00</td>
      <td>return</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0x97</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (imm != 0) ? (dst % imm) : dst</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x9c</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32)((src != 0) ? (dst % src) : dst)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0x9f</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (src != 0) ? (dst % src) : dst</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xa4</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32)(dst ^ imm)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xa5</td>
      <td>0x0</td>
      <td>any</td>
      <td>if dst &lt; imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xa6</td>
      <td>0x0</td>
      <td>any</td>
      <td>if (u32)dst &lt; imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xa7</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst ^= imm</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xac</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32)(dst ^ src)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xad</td>
      <td>any</td>
      <td>0x00</td>
      <td>if dst &lt; src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xae</td>
      <td>any</td>
      <td>0x00</td>
      <td>if (u32)dst &lt; (u32)src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xaf</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst ^= src</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xb4</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32) imm</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xb5</td>
      <td>0x0</td>
      <td>any</td>
      <td>if dst &lt;= imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xa6</td>
      <td>0x0</td>
      <td>any</td>
      <td>if (u32)dst &lt;= imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xb7</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = imm</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xbc</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32) src</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xbd</td>
      <td>any</td>
      <td>0x00</td>
      <td>if dst &lt;= src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xbe</td>
      <td>any</td>
      <td>0x00</td>
      <td>if (u32)dst &lt;= (u32)src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xbf</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = src</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xc3</td>
      <td>any</td>
      <td>0x00</td>
      <td>lock *(u32 *)(dst + offset) += src</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td>0xc3</td>
      <td>any</td>
      <td>0x01</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u32 *)(dst + offset) += src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>src = *(u32 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td>0xc3</td>
      <td>any</td>
      <td>0x40</td>
      <td>*(u32 *)(dst + offset) |= src</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td>0xc3</td>
      <td>any</td>
      <td>0x41</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u32 *)(dst + offset) |= src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>src = *(u32 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td>0xc3</td>
      <td>any</td>
      <td>0x50</td>
      <td>*(u32 *)(dst + offset) &amp;= src</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td>0xc3</td>
      <td>any</td>
      <td>0x51</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u32 *)(dst + offset) &amp;= src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>src = *(u32 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td>0xc3</td>
      <td>any</td>
      <td>0xa0</td>
      <td>*(u32 *)(dst + offset) ^= src</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td>0xc3</td>
      <td>any</td>
      <td>0xa1</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u32 *)(dst + offset) ^= src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>src = *(u32 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td>0xc3</td>
      <td>any</td>
      <td>0xe1</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>temp = *(u32 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u32 *)(dst + offset) = src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>src = temp</td>
      <td></td>
     </tr>
     <tr>
      <td>0xc3</td>
      <td>any</td>
      <td>0xf1</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>temp = *(u32 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>if *(u32)(dst + offset) == R0</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u32)(dst + offset) = src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>R0 = temp</td>
      <td></td>
     </tr>
     <tr>
      <td>0xc4</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst = (u32)(dst s&gt;&gt; imm)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xc5</td>
      <td>0x0</td>
      <td>any</td>
      <td>if dst s&lt; imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xc6</td>
      <td>0x0</td>
      <td>any</td>
      <td>if (s32)dst s&lt; (s32)imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xc7</td>
      <td>0x0</td>
      <td>any</td>
      <td>dst s&gt;&gt;= imm</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xcc</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst = (u32)(dst s&gt;&gt; src)</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xcd</td>
      <td>any</td>
      <td>0x00</td>
      <td>if dst s&lt; src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xce</td>
      <td>any</td>
      <td>0x00</td>
      <td>if (s32)dst s&lt; (s32)src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xcf</td>
      <td>any</td>
      <td>0x00</td>
      <td>dst s&gt;&gt;= src</td>
      <td><xref target="arithmetic-instructions">Arithmetic instructions</xref></td>
     </tr>
     <tr>
      <td>0xd4</td>
      <td>0x0</td>
      <td>0x10</td>
      <td>dst = htole16(dst)</td>
      <td><xref target="byte-swap-instructions">Byte swap instructions</xref></td>
     </tr>
     <tr>
      <td>0xd4</td>
      <td>0x0</td>
      <td>0x20</td>
      <td>dst = htole32(dst)</td>
      <td><xref target="byte-swap-instructions">Byte swap instructions</xref></td>
     </tr>
     <tr>
      <td>0xd4</td>
      <td>0x0</td>
      <td>0x40</td>
      <td>dst = htole64(dst)</td>
      <td><xref target="byte-swap-instructions">Byte swap instructions</xref></td>
     </tr>
     <tr>
      <td>0xd5</td>
      <td>0x0</td>
      <td>any</td>
      <td>if dst s&lt;= imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xd6</td>
      <td>0x0</td>
      <td>any</td>
      <td>if (s32)dst s&lt;= (s32)imm goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xdb</td>
      <td>any</td>
      <td>0x00</td>
      <td>lock *(u64 *)(dst + offset) += src</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td>0xdb</td>
      <td>any</td>
      <td>0x01</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u64 *)(dst + offset) += src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>src = *(u64 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td>0xdb</td>
      <td>any</td>
      <td>0x40</td>
      <td>*(u64 *)(dst + offset) |= src</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td>0xdb</td>
      <td>any</td>
      <td>0x41</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u64 *)(dst + offset) |= src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>lock src = *(u64 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td>0xdb</td>
      <td>any</td>
      <td>0x50</td>
      <td>*(u64 *)(dst + offset) &amp;= src</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td>0xdb</td>
      <td>any</td>
      <td>0x51</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u64 *)(dst + offset) &amp;= src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>src = *(u64 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td>0xdb</td>
      <td>any</td>
      <td>0xa0</td>
      <td>*(u64 *)(dst + offset) ^= src</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td>0xdb</td>
      <td>any</td>
      <td>0xa1</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u64 *)(dst + offset) ^= src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>src = *(u64 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td>0xdb</td>
      <td>any</td>
      <td>0xe1</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>temp = *(u64 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u64 *)(dst + offset) = src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>src = temp</td>
      <td></td>
     </tr>
     <tr>
      <td>0xdb</td>
      <td>any</td>
      <td>0xf1</td>
      <td>lock:</td>
      <td><xref target="atomic-operations">Atomic operations</xref></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>temp = *(u64 *)(dst + offset)</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>if *(u64)(dst + offset) == R0</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>*(u64)(dst + offset) = src</td>
      <td></td>
     </tr>
     <tr>
      <td></td>
      <td></td>
      <td></td>
      <td>R0 = temp</td>
      <td></td>
     </tr>
     <tr>
      <td>0xdc</td>
      <td>0x0</td>
      <td>0x10</td>
      <td>dst = htobe16(dst)</td>
      <td><xref target="byte-swap-instructions">Byte swap instructions</xref></td>
     </tr>
     <tr>
      <td>0xdc</td>
      <td>0x0</td>
      <td>0x20</td>
      <td>dst = htobe32(dst)</td>
      <td><xref target="byte-swap-instructions">Byte swap instructions</xref></td>
     </tr>
     <tr>
      <td>0xdc</td>
      <td>0x0</td>
      <td>0x40</td>
      <td>dst = htobe64(dst)</td>
      <td><xref target="byte-swap-instructions">Byte swap instructions</xref></td>
     </tr>
     <tr>
      <td>0xdd</td>
      <td>any</td>
      <td>0x00</td>
      <td>if dst s&lt;= src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
     <tr>
      <td>0xde</td>
      <td>any</td>
      <td>0x00</td>
      <td>if (s32)dst s&lt;= (s32)src goto +offset</td>
      <td><xref target="jump-instructions">Jump instructions</xref></td>
     </tr>
    </tbody>
   </table>
  </section>
 </middle>
 <back>
 </back>
</rfc>
