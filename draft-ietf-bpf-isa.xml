<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
  <!-- generated by https://github.com/dthaler/rst2rfcxml version 0.1 -->

<!DOCTYPE rfc [
]>

<?rfc rfcedstyle="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-bpf-isa-00" category="std" submissionType="IETF">
 <front>
  <title abbrev="eBPF ISA">
BPF Instruction Set Specification, v1.0
  </title>
  <author initials="D." surname="Thaler" fullname="Dave Thaler" role="editor">
    <organization>Microsoft</organization>
   <address>
    <postal>
    <city>Redmond</city>
    <code>98052</code>
    <country>USA</country>
    <region>WA</region>
    </postal>
    <email>dave.thaler.ietf@gmail.com</email>
   </address>
  </author>
  <abstract>
   <t>
    This document specifies version 1.0 of the BPF instruction set.
   </t>
  </abstract>
 </front>
 <middle>
  <section anchor="documentation-conventions" title="Documentation conventions">
   <t>
    For brevity and consistency, this document refers to families
    of types using a shorthand syntax and refers to several expository,
    mnemonic functions when describing the semantics of instructions.
    The range of valid values for those types and the semantics of those
    functions are defined in the following subsections.
   </t>
   <section anchor="types" title="Types">
    <t>
     This document refers to integer types with the notation <em>SN</em> to specify
     a type's signedness (<em>S</em>) and bit width (<em>N</em>), respectively.
    </t>
    <table>
     <name>Meaning of signedness notation.</name>
     <thead>
      <tr>
       <th><em>S</em></th>
       <th>Meaning</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         <em>u</em>
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         <em>s</em>
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <table>
     <name>Meaning of bit-width notation.</name>
     <thead>
      <tr>
       <th><em>N</em></th>
       <th>Bit width</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         <em>8</em>
        </t>
       </td>
       <td>
        <t>
         8 bits
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         <em>16</em>
        </t>
       </td>
       <td>
        <t>
         16 bits
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         <em>32</em>
        </t>
       </td>
       <td>
        <t>
         32 bits
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         <em>64</em>
        </t>
       </td>
       <td>
        <t>
         64 bits
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         <em>128</em>
        </t>
       </td>
       <td>
        <t>
         128 bits
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     For example, <em>u32</em> is a type whose valid values are all the 32-bit unsigned
     numbers and <em>s16</em> is a types whose valid values are all the 16-bit signed
     numbers.
    </t>
   </section>
   <section anchor="functions" title="Functions">
    <ul>
     <li>
      <em>htobe16</em>: Takes an unsigned 16-bit number in host-endian format and
      returns the equivalent number as an unsigned 16-bit number in big-endian
      format.
     </li>
     <li>
      <em>htobe32</em>: Takes an unsigned 32-bit number in host-endian format and
      returns the equivalent number as an unsigned 32-bit number in big-endian
      format.
     </li>
     <li>
      <em>htobe64</em>: Takes an unsigned 64-bit number in host-endian format and
      returns the equivalent number as an unsigned 64-bit number in big-endian
      format.
     </li>
     <li>
      <em>htole16</em>: Takes an unsigned 16-bit number in host-endian format and
      returns the equivalent number as an unsigned 16-bit number in little-endian
      format.
     </li>
     <li>
      <em>htole32</em>: Takes an unsigned 32-bit number in host-endian format and
      returns the equivalent number as an unsigned 32-bit number in little-endian
      format.
     </li>
     <li>
      <em>htole64</em>: Takes an unsigned 64-bit number in host-endian format and
      returns the equivalent number as an unsigned 64-bit number in little-endian
      format.
     </li>
     <li>
      <em>bswap16</em>: Takes an unsigned 16-bit number in either big- or little-endian
      format and returns the equivalent number with the same bit width but
      opposite endianness.
     </li>
     <li>
      <em>bswap32</em>: Takes an unsigned 32-bit number in either big- or little-endian
      format and returns the equivalent number with the same bit width but
      opposite endianness.
     </li>
     <li>
      <em>bswap64</em>: Takes an unsigned 64-bit number in either big- or little-endian
      format and returns the equivalent number with the same bit width but
      opposite endianness.
     </li>
    </ul>
   </section>
   <section anchor="definitions" title="Definitions">
    <dl>
     <dt anchor="term-sign-extend">
      Sign Extend
     </dt>
     <dd>
      <t>
       To <em>sign extend an</em> <tt>X</tt> <em>-bit number, A, to a</em> <tt>Y</tt> <em>-bit number, B  ,</em> means to
      </t>
      <ol>
       <li>
        Copy all <tt>X</tt> bits from <em>A</em> to the lower <tt>X</tt> bits of <em>B</em>.
       </li>
       <li>
        Set the value of the remaining <tt>Y</tt> - <tt>X</tt> bits of <em>B</em> to the value of
        the  most-significant bit of <em>A</em>.
       </li>
      </ol>
     </dd>
    </dl>
    <aside>
     <t><strong>Example</strong></t>
     <t>
      Sign extend an 8-bit number <tt>A</tt> to a 16-bit number <tt>B</tt> on a big-endian platform:
     </t>
     <artwork>
A:          10000110
B: 11111111 10000110
     </artwork>
    </aside>
   </section>
   <section anchor="conformance-groups" title="Conformance groups">
    <t>
     An implementation does not need to support all instructions specified in this
     document (e.g., deprecated instructions).  Instead, a number of conformance
     groups are specified.  An implementation must support the "basic" conformance
     group and may support additional conformance groups, where supporting a
     conformance group means it must support all instructions in that conformance
     group.
    </t>
    <t>
     The use of named conformance groups enables interoperability between a runtime
     that executes instructions, and tools as such compilers that generate
     instructions for the runtime.  Thus, capability discovery in terms of
     conformance groups might be done manually by users or automatically by tools.
    </t>
    <t>
     Each conformance group has a short ASCII label (e.g., "basic") that
     corresponds to a set of instructions that are mandatory.  That is, each
     instruction has one or more conformance groups of which it is a member.
    </t>
    <t>
     The "basic" conformance group includes all instructions defined in this
     specification unless otherwise noted.
    </t>
   </section>
  </section>
  <section anchor="instruction-encoding" title="Instruction encoding">
   <t>
    BPF has two instruction encodings:
   </t>
   <ul>
    <li>
     the basic instruction encoding, which uses 64 bits to encode an instruction
    </li>
    <li>
     the wide instruction encoding, which appends a second 64-bit immediate (i.e.,
     constant) value after the basic instruction for a total of 128 bits.
    </li>
   </ul>
   <t>
    The fields conforming an encoded basic instruction are stored in the
    following order:
   </t>
   <artwork>
opcode:8 src_reg:4 dst_reg:4 offset:16 imm:32 // In little-endian BPF.
opcode:8 dst_reg:4 src_reg:4 offset:16 imm:32 // In big-endian BPF.
   </artwork>
   <dl>
    <dt anchor="term---imm--">
     <strong>imm</strong>
    </dt>
    <dd>
     <t>
      signed integer immediate value
     </t>
    </dd>
    <dt anchor="term---offset--">
     <strong>offset</strong>
    </dt>
    <dd>
     <t>
      signed integer offset used with pointer arithmetic
     </t>
    </dd>
    <dt anchor="term---src_reg--">
     <strong>src_reg</strong>
    </dt>
    <dd>
     <t>
      the source register number (0-10), except where otherwise specified
      (<xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref> reuse this field for other purposes)
     </t>
    </dd>
    <dt anchor="term---dst_reg--">
     <strong>dst_reg</strong>
    </dt>
    <dd>
     <t>
      destination register number (0-10)
     </t>
    </dd>
    <dt anchor="term---opcode--">
     <strong>opcode</strong>
    </dt>
    <dd>
     <t>
      operation to perform
     </t>
    </dd>
   </dl>
   <t>
    Note that the contents of multi-byte fields ('imm' and 'offset') are
    stored using big-endian byte ordering in big-endian BPF and
    little-endian byte ordering in little-endian BPF.
   </t>
   <t>
    For example:
   </t>
   <artwork>
opcode                  offset imm          assembly
       src_reg dst_reg
07     0       1        00 00  44 33 22 11  r1 += 0x11223344 // little
       dst_reg src_reg
07     1       0        00 00  11 22 33 44  r1 += 0x11223344 // big
   </artwork>
   <t>
    Note that most instructions do not use all of the fields.
    Unused fields shall be cleared to zero.
   </t>
   <t>
    As discussed below in <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>, a 64-bit immediate
    instruction uses a 64-bit immediate value that is constructed as follows.
    The 64 bits following the basic instruction contain a pseudo instruction
    using the same format but with opcode, dst_reg, src_reg, and offset all set to zero,
    and imm containing the high 32 bits of the immediate value.
   </t>
   <t>
    This is depicted in the following figure:
   </t>
   <artwork>
      basic_instruction
.------------------------------.
|                              |
opcode:8 regs:8 offset:16 imm:32 unused:32 imm:32
                                 |              |
                                 '--------------'
                                pseudo instruction
   </artwork>
   <t>
    Thus the 64-bit immediate value is constructed as follows:
   </t>
   <blockquote>
    imm64 = (next_imm &lt;&lt; 32) | imm
   </blockquote>
   <t>
    where 'next_imm' refers to the imm value of the pseudo instruction
    following the basic instruction.  The unused bytes in the pseudo
    instruction are reserved and shall be cleared to zero.
   </t>
   <section anchor="instruction-classes" title="Instruction classes">
    <t>
     The three LSB bits of the 'opcode' field store the instruction class:
    </t>
    <table>
     <thead>
      <tr>
       <th>class</th>
       <th>value</th>
       <th>description</th>
       <th>reference</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x00
        </t>
       </td>
       <td>
        <t>
         non-standard load operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_LDX
        </t>
       </td>
       <td>
        <t>
         0x01
        </t>
       </td>
       <td>
        <t>
         load into register operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_ST
        </t>
       </td>
       <td>
        <t>
         0x02
        </t>
       </td>
       <td>
        <t>
         store from immediate operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_STX
        </t>
       </td>
       <td>
        <t>
         0x03
        </t>
       </td>
       <td>
        <t>
         store from register operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_ALU
        </t>
       </td>
       <td>
        <t>
         0x04
        </t>
       </td>
       <td>
        <t>
         32-bit arithmetic operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JMP
        </t>
       </td>
       <td>
        <t>
         0x05
        </t>
       </td>
       <td>
        <t>
         64-bit jump operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JMP32
        </t>
       </td>
       <td>
        <t>
         0x06
        </t>
       </td>
       <td>
        <t>
         32-bit jump operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_ALU64
        </t>
       </td>
       <td>
        <t>
         0x07
        </t>
       </td>
       <td>
        <t>
         64-bit arithmetic operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
     </tbody>
    </table>
   </section>
  </section>
  <section anchor="arithmetic-and-jump-instructions" title="Arithmetic and jump instructions">
   <t>
    For arithmetic and jump instructions (<tt>BPF_ALU</tt>, <tt>BPF_ALU64</tt>, <tt>BPF_JMP</tt> and
    <tt>BPF_JMP32</tt>), the 8-bit 'opcode' field is divided into three parts:
   </t>
   <table>
    <thead>
     <tr>
      <th>4 bits (MSB)</th>
      <th>1 bit</th>
      <th>3 bits (LSB)</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        code
       </t>
      </td>
      <td>
       <t>
        source
       </t>
      </td>
      <td>
       <t>
        instruction class
       </t>
      </td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt anchor="term---code--">
     <strong>code</strong>
    </dt>
    <dd>
     <t>
      the operation code, whose meaning varies by instruction class
     </t>
    </dd>
    <dt anchor="term---source--">
     <strong>source</strong>
    </dt>
    <dd>
     <t>
      the source operand location, which unless otherwise specified is one of:
     </t>
    </dd>
   </dl>
   <table>
    <thead>
     <tr>
      <th>source</th>
      <th>value</th>
      <th>description</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        BPF_K
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        use 32-bit 'imm' value as source operand
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_X
       </t>
      </td>
      <td>
       <t>
        0x08
       </t>
      </td>
      <td>
       <t>
        use 'src_reg' register value as source operand
       </t>
      </td>
     </tr>
    </tbody>
   </table>
   <dl>
    <dt anchor="term---instruction-class--">
     <strong>instruction class</strong>
    </dt>
    <dd>
     <t>
      the instruction class (see <xref target="instruction-classes">Instruction classes</xref>)
     </t>
    </dd>
   </dl>
   <section anchor="arithmetic-instructions" title="Arithmetic instructions">
    <t>
     <tt>BPF_ALU</tt> uses 32-bit wide operands while <tt>BPF_ALU64</tt> uses 64-bit wide operands for
     otherwise identical operations.
     The 'code' field encodes the operation as below, where 'src' and 'dst' refer
     to the values of the source and destination registers, respectively.
    </t>
    <table>
     <thead>
      <tr>
       <th>code</th>
       <th>value</th>
       <th>offset</th>
       <th>description</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_ADD
        </t>
       </td>
       <td>
        <t>
         0x00
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst += src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_SUB
        </t>
       </td>
       <td>
        <t>
         0x10
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst -= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_MUL
        </t>
       </td>
       <td>
        <t>
         0x20
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst *= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_DIV
        </t>
       </td>
       <td>
        <t>
         0x30
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst = (src != 0) ? (dst / src) : 0
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_SDIV
        </t>
       </td>
       <td>
        <t>
         0x30
        </t>
       </td>
       <td>
        <t>
         1
        </t>
       </td>
       <td>
        <t>
         dst = (src != 0) ? (dst s/ src) : 0
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_OR
        </t>
       </td>
       <td>
        <t>
         0x40
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst |= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_AND
        </t>
       </td>
       <td>
        <t>
         0x50
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst &amp;= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_LSH
        </t>
       </td>
       <td>
        <t>
         0x60
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst &lt;&lt;= (src &amp; mask)
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_RSH
        </t>
       </td>
       <td>
        <t>
         0x70
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst &gt;&gt;= (src &amp; mask)
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_NEG
        </t>
       </td>
       <td>
        <t>
         0x80
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst = -dst
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_MOD
        </t>
       </td>
       <td>
        <t>
         0x90
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst = (src != 0) ? (dst % src) : dst
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_SMOD
        </t>
       </td>
       <td>
        <t>
         0x90
        </t>
       </td>
       <td>
        <t>
         1
        </t>
       </td>
       <td>
        <t>
         dst = (src != 0) ? (dst s% src) : dst
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_XOR
        </t>
       </td>
       <td>
        <t>
         0xa0
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst ^= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_MOV
        </t>
       </td>
       <td>
        <t>
         0xb0
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst = src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_MOVSX
        </t>
       </td>
       <td>
        <t>
         0xb0
        </t>
       </td>
       <td>
        <t>
         8/16/32
        </t>
       </td>
       <td>
        <t>
         dst = (s8,s16,s32)src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_ARSH
        </t>
       </td>
       <td>
        <t>
         0xc0
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         <xref target="term-sign-extend">sign extending</xref> dst &gt;&gt;= (src &amp; mask)
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_END
        </t>
       </td>
       <td>
        <t>
         0xd0
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         byte swap operations (see <xref target="byte-swap-instructions">Byte swap instructions</xref> below)
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     Underflow and overflow are allowed during arithmetic operations, meaning
     the 64-bit or 32-bit value will wrap. If BPF program execution would
     result in division by zero, the destination register is instead set to zero.
     If execution would result in modulo by zero, for <tt>BPF_ALU64</tt> the value of
     the destination register is unchanged whereas for <tt>BPF_ALU</tt> the upper
     32 bits of the destination register are zeroed.
    </t>
    <t>
     <tt>BPF_ADD | BPF_X | BPF_ALU</tt> means:
    </t>
    <artwork>
dst = (u32) ((u32) dst + (u32) src)
    </artwork>
    <t>
     where '(u32)' indicates that the upper 32 bits are zeroed.
    </t>
    <t>
     <tt>BPF_ADD | BPF_X | BPF_ALU64</tt> means:
    </t>
    <artwork>
dst = dst + src
    </artwork>
    <t>
     <tt>BPF_XOR | BPF_K | BPF_ALU</tt> means:
    </t>
    <artwork>
dst = (u32) dst ^ (u32) imm32
    </artwork>
    <t>
     <tt>BPF_XOR | BPF_K | BPF_ALU64</tt> means:
    </t>
    <artwork>
dst = dst ^ imm32
    </artwork>
    <t>
     Note that most instructions have instruction offset of 0. Only three instructions
     (<tt>BPF_SDIV</tt>, <tt>BPF_SMOD</tt>, <tt>BPF_MOVSX</tt>) have a non-zero offset.
    </t>
    <t>
     The division and modulo operations support both unsigned and signed flavors.
    </t>
    <t>
     For unsigned operations (<tt>BPF_DIV</tt> and <tt>BPF_MOD</tt>), for <tt>BPF_ALU</tt>,
     'imm' is interpreted as a 32-bit unsigned value. For <tt>BPF_ALU64</tt>,
     'imm' is first <xref target="term-sign-extend">sign extended</xref> from 32 to 64 bits, and then
     interpreted as a 64-bit unsigned value.
    </t>
    <t>
     For signed operations (<tt>BPF_SDIV</tt> and <tt>BPF_SMOD</tt>), for <tt>BPF_ALU</tt>,
     'imm' is interpreted as a 32-bit signed value. For <tt>BPF_ALU64</tt>, 'imm'
     is first <xref target="term-sign-extend">sign extended</xref> from 32 to 64 bits, and then
     interpreted as a 64-bit signed value.
    </t>
    <t>
     Note that there are varying definitions of the signed modulo operation
     when the dividend or divisor are negative, where implementations often
     vary by language such that Python, Ruby, etc.  differ from C, Go, Java,
     etc. This specification requires that signed modulo use truncated division
     (where -13 % 3 == -1) as implemented in C, Go, etc.:
    </t>
    <blockquote>
     a % n = a - n * trunc(a / n)
    </blockquote>
    <t>
     The <tt>BPF_MOVSX</tt> instruction does a move operation with sign extension.
     <tt>BPF_ALU | BPF_MOVSX</tt> <xref target="term-sign-extend">sign extends</xref> 8-bit and 16-bit operands into 32
     bit operands, and zeroes the remaining upper 32 bits.
     <tt>BPF_ALU64 | BPF_MOVSX</tt> <xref target="term-sign-extend">sign extends</xref> 8-bit, 16-bit, and 32-bit
     operands into 64 bit operands.  Unlike other arithmetic instructions,
     <tt>BPF_MOVSX</tt> is only defined for register source operands (<tt>BPF_X</tt>).
    </t>
    <t>
     The <tt>BPF_NEG</tt> instruction is only defined when the source bit is clear
     (<tt>BPF_K</tt>).
    </t>
    <t>
     Shift operations use a mask of 0x3F (63) for 64-bit operations and 0x1F (31)
     for 32-bit operations.
    </t>
   </section>
   <section anchor="byte-swap-instructions" title="Byte swap instructions">
    <t>
     The byte swap instructions use instruction classes of <tt>BPF_ALU</tt> and <tt>BPF_ALU64</tt>
     and a 4-bit 'code' field of <tt>BPF_END</tt>.
    </t>
    <t>
     The byte swap instructions operate on the destination register
     only and do not use a separate source register or immediate value.
    </t>
    <t>
     For <tt>BPF_ALU</tt>, the 1-bit source operand field in the opcode is used to
     select what byte order the operation converts from or to. For
     <tt>BPF_ALU64</tt>, the 1-bit source operand field in the opcode is reserved
     and must be set to 0.
    </t>
    <table>
     <thead>
      <tr>
       <th>class</th>
       <th>source</th>
       <th>value</th>
       <th>description</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_ALU
        </t>
       </td>
       <td>
        <t>
         BPF_TO_LE
        </t>
       </td>
       <td>
        <t>
         0x00
        </t>
       </td>
       <td>
        <t>
         convert between host byte order and little endian
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_ALU
        </t>
       </td>
       <td>
        <t>
         BPF_TO_BE
        </t>
       </td>
       <td>
        <t>
         0x08
        </t>
       </td>
       <td>
        <t>
         convert between host byte order and big endian
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_ALU64
        </t>
       </td>
       <td>
        <t>
         Reserved
        </t>
       </td>
       <td>
        <t>
         0x00
        </t>
       </td>
       <td>
        <t>
         do byte swap unconditionally
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     The 'imm' field encodes the width of the swap operations.  The following widths
     are supported: 16, 32 and 64.
    </t>
    <t>
     Examples:
    </t>
    <t>
     <tt>BPF_ALU | BPF_TO_LE | BPF_END</tt> with imm = 16/32/64 means:
    </t>
    <artwork>
dst = htole16(dst)
dst = htole32(dst)
dst = htole64(dst)
    </artwork>
    <t>
     <tt>BPF_ALU | BPF_TO_BE | BPF_END</tt> with imm = 16/32/64 means:
    </t>
    <artwork>
dst = htobe16(dst)
dst = htobe32(dst)
dst = htobe64(dst)
    </artwork>
    <t>
     <tt>BPF_ALU64 | BPF_TO_LE | BPF_END</tt> with imm = 16/32/64 means:
    </t>
    <artwork>
dst = bswap16(dst)
dst = bswap32(dst)
dst = bswap64(dst)
    </artwork>
   </section>
   <section anchor="jump-instructions" title="Jump instructions">
    <t>
     <tt>BPF_JMP32</tt> uses 32-bit wide operands while <tt>BPF_JMP</tt> uses 64-bit wide operands for
     otherwise identical operations.
     The 'code' field encodes the operation as below:
    </t>
    <table>
     <thead>
      <tr>
       <th>code</th>
       <th>value</th>
       <th>src</th>
       <th>description</th>
       <th>notes</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_JA
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         PC += offset
        </t>
       </td>
       <td>
        <t>
         BPF_JMP | BPF_K only
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JA
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         PC += imm
        </t>
       </td>
       <td>
        <t>
         BPF_JMP32 | BPF_K only
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JEQ
        </t>
       </td>
       <td>
        <t>
         0x1
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst == src
        </t>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JGT
        </t>
       </td>
       <td>
        <t>
         0x2
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt; src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JGE
        </t>
       </td>
       <td>
        <t>
         0x3
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt;= src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JSET
        </t>
       </td>
       <td>
        <t>
         0x4
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &amp; src
        </t>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JNE
        </t>
       </td>
       <td>
        <t>
         0x5
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst != src
        </t>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JSGT
        </t>
       </td>
       <td>
        <t>
         0x6
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt; src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JSGE
        </t>
       </td>
       <td>
        <t>
         0x7
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt;= src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_CALL
        </t>
       </td>
       <td>
        <t>
         0x8
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         call helper function by address
        </t>
       </td>
       <td>
        <t>
         BPF_JMP | BPF_K only, see <xref target="helper-functions">Helper functions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_CALL
        </t>
       </td>
       <td>
        <t>
         0x8
        </t>
       </td>
       <td>
        <t>
         0x1
        </t>
       </td>
       <td>
        <t>
         call PC += imm
        </t>
       </td>
       <td>
        <t>
         BPF_JMP | BPF_K only, see <xref target="program-local-functions">Program-local functions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_CALL
        </t>
       </td>
       <td>
        <t>
         0x8
        </t>
       </td>
       <td>
        <t>
         0x2
        </t>
       </td>
       <td>
        <t>
         call helper function by BTF ID
        </t>
       </td>
       <td>
        <t>
         BPF_JMP | BPF_K only, see <xref target="helper-functions">Helper functions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_EXIT
        </t>
       </td>
       <td>
        <t>
         0x9
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         return
        </t>
       </td>
       <td>
        <t>
         BPF_JMP | BPF_K only
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JLT
        </t>
       </td>
       <td>
        <t>
         0xa
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt; src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JLE
        </t>
       </td>
       <td>
        <t>
         0xb
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt;= src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JSLT
        </t>
       </td>
       <td>
        <t>
         0xc
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt; src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_JSLE
        </t>
       </td>
       <td>
        <t>
         0xd
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt;= src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     The BPF program needs to store the return value into register R0 before doing a
     <tt>BPF_EXIT</tt>.
    </t>
    <t>
     Example:
    </t>
    <t>
     <tt>BPF_JSGE | BPF_X | BPF_JMP32</tt> (0x7e) means:
    </t>
    <artwork>
if (s32)dst s&gt;= (s32)src goto +offset
    </artwork>
    <t>
     where 's&gt;=' indicates a signed '&gt;=' comparison.
    </t>
    <t>
     <tt>BPF_JA | BPF_K | BPF_JMP32</tt> (0x06) means:
    </t>
    <artwork>
gotol +imm
    </artwork>
    <t>
     where 'imm' means the branch offset comes from insn 'imm' field.
    </t>
    <t>
     Note that there are two flavors of <tt>BPF_JA</tt> instructions. The
     <tt>BPF_JMP</tt> class permits a 16-bit jump offset specified by the 'offset'
     field, whereas the <tt>BPF_JMP32</tt> class permits a 32-bit jump offset
     specified by the 'imm' field. A &gt; 16-bit conditional jump may be
     converted to a &lt; 16-bit conditional jump plus a 32-bit unconditional
     jump.
    </t>
    <section anchor="helper-functions" title="Helper functions">
     <t>
      Helper functions are a concept whereby BPF programs can call into a
      set of function calls exposed by the underlying platform.
     </t>
     <t>
      Historically, each helper function was identified by an address
      encoded in the imm field.  The available helper functions may differ
      for each program type, but address values are unique across all program types.
     </t>
     <t>
      Platforms that support the BPF Type Format (BTF) support identifying
      a helper function by a BTF ID encoded in the imm field, where the BTF ID
      identifies the helper name and type.
     </t>
    </section>
    <section anchor="program-local-functions" title="Program-local functions">
     <t>
      Program-local functions are functions exposed by the same BPF program as the
      caller, and are referenced by offset from the call instruction, similar to
      <tt>BPF_JA</tt>.  The offset is encoded in the imm field of the call instruction.
      A <tt>BPF_EXIT</tt> within the program-local function will return to the caller.
     </t>
    </section>
   </section>
  </section>
  <section anchor="load-and-store-instructions" title="Load and store instructions">
   <t>
    For load and store instructions (<tt>BPF_LD</tt>, <tt>BPF_LDX</tt>, <tt>BPF_ST</tt>, and <tt>BPF_STX</tt>), the
    8-bit 'opcode' field is divided as:
   </t>
   <table>
    <thead>
     <tr>
      <th>3 bits (MSB)</th>
      <th>2 bits</th>
      <th>3 bits (LSB)</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        mode
       </t>
      </td>
      <td>
       <t>
        size
       </t>
      </td>
      <td>
       <t>
        instruction class
       </t>
      </td>
     </tr>
    </tbody>
   </table>
   <t>
    The mode modifier is one of:
   </t>
   <table>
    <thead>
     <tr>
      <th>mode modifier</th>
      <th>value</th>
      <th>description</th>
      <th>reference</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        BPF_IMM
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        64-bit immediate instructions
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_ABS
       </t>
      </td>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        legacy BPF packet access (absolute)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_IND
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        legacy BPF packet access (indirect)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_MEM
       </t>
      </td>
      <td>
       <t>
        0x60
       </t>
      </td>
      <td>
       <t>
        regular load and store operations
       </t>
      </td>
      <td>
       <t>
        <xref target="regular-load-and-store-operations">Regular load and store operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_MEMSX
       </t>
      </td>
      <td>
       <t>
        0x80
       </t>
      </td>
      <td>
       <t>
        sign-extension load operations
       </t>
      </td>
      <td>
       <t>
        <xref target="sign-extension-load-operations">Sign-extension load operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_ATOMIC
       </t>
      </td>
      <td>
       <t>
        0xc0
       </t>
      </td>
      <td>
       <t>
        atomic operations
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
    </tbody>
   </table>
   <t>
    The size modifier is one of:
   </t>
   <table>
    <thead>
     <tr>
      <th>size modifier</th>
      <th>value</th>
      <th>description</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        BPF_W
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        word        (4 bytes)
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_H
       </t>
      </td>
      <td>
       <t>
        0x08
       </t>
      </td>
      <td>
       <t>
        half word   (2 bytes)
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_B
       </t>
      </td>
      <td>
       <t>
        0x10
       </t>
      </td>
      <td>
       <t>
        byte
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        BPF_DW
       </t>
      </td>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        double word (8 bytes)
       </t>
      </td>
     </tr>
    </tbody>
   </table>
   <section anchor="regular-load-and-store-operations" title="Regular load and store operations">
    <t>
     The <tt>BPF_MEM</tt> mode modifier is used to encode regular load and store
     instructions that transfer data between a register and memory.
    </t>
    <t>
     <tt>BPF_MEM | &lt;size&gt; | BPF_STX</tt> means:
    </t>
    <artwork>
*(size *) (dst + offset) = src
    </artwork>
    <t>
     <tt>BPF_MEM | &lt;size&gt; | BPF_ST</tt> means:
    </t>
    <artwork>
*(size *) (dst + offset) = imm32
    </artwork>
    <t>
     <tt>BPF_MEM | &lt;size&gt; | BPF_LDX</tt> means:
    </t>
    <artwork>
dst = *(unsigned size *) (src + offset)
    </artwork>
    <t>
     Where size is one of: <tt>BPF_B</tt>, <tt>BPF_H</tt>, <tt>BPF_W</tt>, or <tt>BPF_DW</tt> and
     'unsigned size' is one of u8, u16, u32 or u64.
    </t>
   </section>
   <section anchor="sign-extension-load-operations" title="Sign-extension load operations">
    <t>
     The <tt>BPF_MEMSX</tt> mode modifier is used to encode <xref target="term-sign-extend">sign-extension</xref> load
     instructions that transfer data between a register and memory.
    </t>
    <t>
     <tt>BPF_MEMSX | &lt;size&gt; | BPF_LDX</tt> means:
    </t>
    <artwork>
dst = *(signed size *) (src + offset)
    </artwork>
    <t>
     Where size is one of: <tt>BPF_B</tt>, <tt>BPF_H</tt> or <tt>BPF_W</tt>, and
     'signed size' is one of s8, s16 or s32.
    </t>
   </section>
   <section anchor="atomic-operations" title="Atomic operations">
    <t>
     Atomic operations are operations that operate on memory and can not be
     interrupted or corrupted by other access to the same memory region
     by other BPF programs or means outside of this specification.
    </t>
    <t>
     All atomic operations supported by BPF are encoded as store operations
     that use the <tt>BPF_ATOMIC</tt> mode modifier as follows:
    </t>
    <ul>
     <li>
      <tt>BPF_ATOMIC | BPF_W | BPF_STX</tt> for 32-bit operations
     </li>
     <li>
      <tt>BPF_ATOMIC | BPF_DW | BPF_STX</tt> for 64-bit operations
     </li>
     <li>
      8-bit and 16-bit wide atomic operations are not supported.
     </li>
    </ul>
    <t>
     The 'imm' field is used to encode the actual atomic operation.
     Simple atomic operation use a subset of the values defined to encode
     arithmetic operations in the 'imm' field to encode the atomic operation:
    </t>
    <table>
     <thead>
      <tr>
       <th>imm</th>
       <th>value</th>
       <th>description</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_ADD
        </t>
       </td>
       <td>
        <t>
         0x00
        </t>
       </td>
       <td>
        <t>
         atomic add
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_OR
        </t>
       </td>
       <td>
        <t>
         0x40
        </t>
       </td>
       <td>
        <t>
         atomic or
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_AND
        </t>
       </td>
       <td>
        <t>
         0x50
        </t>
       </td>
       <td>
        <t>
         atomic and
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_XOR
        </t>
       </td>
       <td>
        <t>
         0xa0
        </t>
       </td>
       <td>
        <t>
         atomic xor
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     <tt>BPF_ATOMIC | BPF_W  | BPF_STX</tt> with 'imm' = BPF_ADD means:
    </t>
    <artwork>
*(u32 *)(dst + offset) += src
    </artwork>
    <t>
     <tt>BPF_ATOMIC | BPF_DW | BPF_STX</tt> with 'imm' = BPF ADD means:
    </t>
    <artwork>
*(u64 *)(dst + offset) += src
    </artwork>
    <t>
     In addition to the simple atomic operations, there also is a modifier and
     two complex atomic operations:
    </t>
    <table>
     <thead>
      <tr>
       <th>imm</th>
       <th>value</th>
       <th>description</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_FETCH
        </t>
       </td>
       <td>
        <t>
         0x01
        </t>
       </td>
       <td>
        <t>
         modifier: return old value
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_XCHG
        </t>
       </td>
       <td>
        <t>
         0xe0 | BPF_FETCH
        </t>
       </td>
       <td>
        <t>
         atomic exchange
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_CMPXCHG
        </t>
       </td>
       <td>
        <t>
         0xf0 | BPF_FETCH
        </t>
       </td>
       <td>
        <t>
         atomic compare and exchange
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     The <tt>BPF_FETCH</tt> modifier is optional for simple atomic operations, and
     always set for the complex atomic operations.  If the <tt>BPF_FETCH</tt> flag
     is set, then the operation also overwrites <tt>src</tt> with the value that
     was in memory before it was modified.
    </t>
    <t>
     The <tt>BPF_XCHG</tt> operation atomically exchanges <tt>src</tt> with the value
     addressed by <tt>dst + offset</tt>.
    </t>
    <t>
     The <tt>BPF_CMPXCHG</tt> operation atomically compares the value addressed by
     <tt>dst + offset</tt> with <tt>R0</tt>. If they match, the value addressed by
     <tt>dst + offset</tt> is replaced with <tt>src</tt>. In either case, the
     value that was at <tt>dst + offset</tt> before the operation is zero-extended
     and loaded back to <tt>R0</tt>.
    </t>
   </section>
   <section anchor="-4-bit-immediate-instructions" title="64-bit immediate instructions">
    <t>
     Instructions with the <tt>BPF_IMM</tt> 'mode' modifier use the wide instruction
     encoding defined in <xref target="instruction-encoding">Instruction encoding</xref>, and use the 'src' field of the
     basic instruction to hold an opcode subtype.
    </t>
    <t>
     The following table defines a set of <tt>BPF_IMM | BPF_DW | BPF_LD</tt> instructions
     with opcode subtypes in the 'src' field, using new terms such as "map"
     defined further below:
    </t>
    <table>
     <thead>
      <tr>
       <th>opcode construction</th>
       <th>opcode</th>
       <th>src</th>
       <th>pseudocode</th>
       <th>imm type</th>
       <th>dst type</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         dst = imm64
        </t>
       </td>
       <td>
        <t>
         integer
        </t>
       </td>
       <td>
        <t>
         integer
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x1
        </t>
       </td>
       <td>
        <t>
         dst = map_by_fd(imm)
        </t>
       </td>
       <td>
        <t>
         map fd
        </t>
       </td>
       <td>
        <t>
         map
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x2
        </t>
       </td>
       <td>
        <t>
         dst = map_val(map_by_fd(imm)) + next_imm
        </t>
       </td>
       <td>
        <t>
         map fd
        </t>
       </td>
       <td>
        <t>
         data pointer
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x3
        </t>
       </td>
       <td>
        <t>
         dst = var_addr(imm)
        </t>
       </td>
       <td>
        <t>
         variable id
        </t>
       </td>
       <td>
        <t>
         data pointer
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x4
        </t>
       </td>
       <td>
        <t>
         dst = code_addr(imm)
        </t>
       </td>
       <td>
        <t>
         integer
        </t>
       </td>
       <td>
        <t>
         code pointer
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x5
        </t>
       </td>
       <td>
        <t>
         dst = map_by_idx(imm)
        </t>
       </td>
       <td>
        <t>
         map index
        </t>
       </td>
       <td>
        <t>
         map
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         BPF_IMM | BPF_DW | BPF_LD
        </t>
       </td>
       <td>
        <t>
         0x18
        </t>
       </td>
       <td>
        <t>
         0x6
        </t>
       </td>
       <td>
        <t>
         dst = map_val(map_by_idx(imm)) + next_imm
        </t>
       </td>
       <td>
        <t>
         map index
        </t>
       </td>
       <td>
        <t>
         data pointer
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     where
    </t>
    <ul>
     <li>
      map_by_fd(imm) means to convert a 32-bit file descriptor into an address of a map (see <xref target="maps">Maps</xref>)
     </li>
     <li>
      map_by_idx(imm) means to convert a 32-bit index into an address of a map
     </li>
     <li>
      map_val(map) gets the address of the first value in a given map
     </li>
     <li>
      var_addr(imm) gets the address of a platform variable (see <xref target="platform-variables">Platform Variables</xref>) with a given id
     </li>
     <li>
      code_addr(imm) gets the address of the instruction at a specified relative offset in number of (64-bit) instructions
     </li>
     <li>
      the 'imm type' can be used by disassemblers for display
     </li>
     <li>
      the 'dst type' can be used for verification and JIT compilation purposes
     </li>
    </ul>
    <section anchor="maps" title="Maps">
     <t>
      Maps are shared memory regions accessible by BPF programs on some platforms.
      A map can have various semantics as defined in a separate document, and may or
      may not have a single contiguous memory region, but the 'map_val(map)' is
      currently only defined for maps that do have a single contiguous memory region.
     </t>
     <t>
      Each map can have a file descriptor (fd) if supported by the platform, where
      'map_by_fd(imm)' means to get the map with the specified file descriptor. Each
      BPF program can also be defined to use a set of maps associated with the
      program at load time, and 'map_by_idx(imm)' means to get the map with the given
      index in the set associated with the BPF program containing the instruction.
     </t>
    </section>
    <section anchor="platform-variables" title="Platform Variables">
     <t>
      Platform variables are memory regions, identified by integer ids, exposed by
      the runtime and accessible by BPF programs on some platforms.  The
      'var_addr(imm)' operation means to get the address of the memory region
      identified by the given id.
     </t>
    </section>
   </section>
   <section anchor="legacy-bpf-packet-access-instructions" title="Legacy BPF Packet access instructions">
    <t>
     BPF previously introduced special instructions for access to packet data that were
     carried over from classic BPF. However, these instructions are
     deprecated and should no longer be used.  All legacy packet access
     instructions belong to the "legacy" conformance group instead of the "basic"
     conformance group.
    </t>
   </section>
  </section>
  <section anchor="iana-considerations" title="IANA Considerations">
   <t>
    This document proposes a new IANA registry for BPF instructions, as follows:
   </t>
   <ul>
    <li>
     Name of the registry: BPF Instruction Set
    </li>
    <li>
     Name of the registry group: same as registry name
    </li>
    <li>
     Required information for registrations: The values to appear in the entry fields.
    </li>
    <li>
     Syntax of registry entries: Each entry has the following fields:
     <ul>
      <li>
       opcode: a 1-byte value in hex format indicating the value of the opcode field
      </li>
      <li>
       src: either a value indicating the value of the src field, or "any"
      </li>
      <li>
       imm: either a value indicating the value of the imm field, or "any"
      </li>
      <li>
       offset: either a value indicating the value of the offset field, or "any"
      </li>
      <li>
       description: description of what the instruction does, typically in pseudocode
      </li>
      <li>
       reference: a reference to the defining specification
      </li>
      <li>
       status: Permanent, Provisional, or Historical
      </li>
     </ul>
    </li>
    <li>
     Registration policy (see <xref target="RFC8126" section="4"/> for details):
     <ul>
      <li>
       Permanent: Standards action or IESG Review
      </li>
      <li>
       Provisional: Specification required
      </li>
      <li>
       Historical: Specification required
      </li>
     </ul>
    </li>
    <li>
     Initial registrations: See the Appendix. Instructions other than those listed
     as deprecated are Permanent. Any listed as deprecated are Historical.
    </li>
   </ul>
  </section>
  <section anchor="acknowledgements" title="Acknowledgements">
   <t>
    This draft was generated from instruction-set.rst in the Linux
    kernel repository, to which a number of other individuals have authored contributions
    over time, including Akhil Raj, Alexei Starovoitov, Brendan Jackman, Christoph Hellwig, Daniel Borkmann,
    Ilya Leoshkevich, Jiong Wang, Jose E. Marchesi, Kosuke Fujimoto,
    Shahab Vahedi, Tiezhu Yang, Will Hawkins, and Zheng Yejian, with review and suggestions by many others including
    Alan Jowett, Andrii Nakryiko, David Vernet, Jim Harris,
    Quentin Monnet, Song Liu, Shung-Hsi Yu, Stanislav Fomichev, and Yonghong Song.
   </t>
  </section>
  <section anchor="appendix" title="Appendix">
   <t>
    Initial values for the BPF Instruction registry are given below.
    The descriptions in this table are informative. In case of any discrepancy, the reference
    is authoritative.
   </t>
   <table>
    <thead>
     <tr>
      <th>opcode</th>
      <th>src</th>
      <th>imm</th>
      <th>offset</th>
      <th>description</th>
      <th>reference</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        (additional immediate value)
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x04
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst + (u32)imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x05
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x06
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        goto +imm
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x07
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst += imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x0c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst + (u32)src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x0f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst += src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x14
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst - (u32)imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x15
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst == imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x16
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst == imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x17
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst -= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = imm64
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = map_by_fd(imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x2
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = mva(map_by_fd(imm)) + next_imm
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = variable_addr(imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x4
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = code_addr(imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x5
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = map_by_idx(imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x6
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = mva(map_by_idx(imm)) + next_imm
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst - (u32)src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst == src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst == (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst -= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x24
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst * imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x25
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &gt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x26
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x27
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst *= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x28
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst * src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &gt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt; (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst *= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x30
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x34
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((imm != 0) ? ((u32)dst / (u32)imm) : 0)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x34
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((imm != 0) ? ((s32)dst s/ imm) : 0)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x35
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &gt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x36
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x37
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (imm != 0) ? (dst / (u32)imm) : 0
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x37
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        dst = (imm != 0) ? (dst s/ imm) : 0
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((src != 0) ? ((u32)dst / (u32)src) : 0)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((src != 0) ? ((s32)dst s/(s32)src) : 0)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &gt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt;= (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (src != 0) ? (dst / src) : 0
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        dst = (src != 0) ? (dst s/ src) : 0
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x44
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst | imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x45
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &amp; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x46
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &amp; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x47
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst |= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x48
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst | src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &amp; src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &amp; (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst |= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x50
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x54
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &amp; imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x55
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst != imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x56
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst != imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x57
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst &amp;= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &amp; src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst != src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst != (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst &amp;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x61
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = *(u32 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x62
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u32 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x63
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u32 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x64
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &lt;&lt; imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x65
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&gt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x66
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt; (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x67
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst &lt;&lt;= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x69
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = *(u16 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6a
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u16 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6b
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u16 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &lt;&lt; src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&gt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt; (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst &lt;&lt;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x71
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = *(u8 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x72
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u8 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x73
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u8 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x74
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &gt;&gt; imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x75
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&gt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x76
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt;= (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x77
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst &gt;&gt;= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x79
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = *(u64 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7a
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u64 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7b
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u64 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &gt;&gt; src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&gt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt;= (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst &gt;&gt;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x84
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)-dst
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x85
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        call helper function by address
       </t>
      </td>
      <td>
       <t>
        <xref target="helper-functions">Helper functions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x85
       </t>
      </td>
      <td>
       <t>
        0x1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        call PC += imm
       </t>
      </td>
      <td>
       <t>
        <xref target="program-local-functions">Program-local functions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x85
       </t>
      </td>
      <td>
       <t>
        0x2
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        call helper function by BTF ID
       </t>
      </td>
      <td>
       <t>
        <xref target="helper-functions">Helper functions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x87
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = -dst
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x94
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((imm != 0)?((u32)dst % (u32)imm) : dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x94
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((imm != 0) ? ((s32)dst s% imm) : dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x95
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        return
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x97
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (imm != 0) ? (dst % (u32)imm) : dst
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x97
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        dst = (imm != 0) ? (dst s% imm) : dst
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x9c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((src != 0)?((u32)dst % (u32)src) : dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x9c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((src != 0)?((s32)dst s% (s32)src) :dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x9f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (src != 0) ? (dst % src) : dst
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x9f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        dst = (src != 0) ? (dst s% src) : dst
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst ^ imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &lt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst ^= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xac
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst ^ src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xad
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &lt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xae
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt; (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xaf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst ^= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xb4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32) imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xb5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &lt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xb6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xb7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbc
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32) src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbc
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        8
       </t>
      </td>
      <td>
       <t>
        dst = (u32) (s32) (s8) src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbc
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        16
       </t>
      </td>
      <td>
       <t>
        dst = (u32) (s32) (s16) src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbd
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &lt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbe
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt;= (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        8
       </t>
      </td>
      <td>
       <t>
        dst = (s64) (s8) src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        16
       </t>
      </td>
      <td>
       <t>
        dst = (s64) (s16) src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        32
       </t>
      </td>
      <td>
       <t>
        dst = (s64) (s32) src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        lock *(u32 *)(dst + offset) += src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x01
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_add_32((u32 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        lock *(u32 *)(dst + offset) |= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x41
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_or_32((u32 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x50
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        lock *(u32 *)(dst + offset) &amp;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x51
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_and_32((u32 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        lock *(u32 *)(dst + offset) ^= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_xor_32((u32 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xe1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        src = xchg_32((u32 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xf1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        r0 = cmpxchg_32((u32 *)(dst + offset), r0, src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst s&gt;&gt; imm)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&lt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt; (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst s&gt;&gt;= imm
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xcc
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst s&gt;&gt; src)
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xcd
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&lt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xce
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt; (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xcf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst s&gt;&gt;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x10
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = htole16(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = htole32(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = htole64(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&lt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt;= (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x10
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = bswap16(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = bswap32(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = bswap64(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        lock *(u64 *)(dst + offset) += src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x01
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_add_64((u64 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        lock *(u64 *)(dst + offset) |= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x41
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_or_64((u64 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x50
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        lock *(u64 *)(dst + offset) &amp;= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x51
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_and_64((u64 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        lock *(u64 *)(dst + offset) ^= src
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_xor_64((u64 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xe1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        src = xchg_64((u64 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xf1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        r0 = cmpxchg_64((u64 *)(dst + offset), r0, src)
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdc
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x10
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = htobe16(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdc
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = htobe32(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdc
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        dst = htobe64(dst)
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdd
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&lt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xde
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt;= (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
    </tbody>
   </table>
  </section>
 </middle>
 <back>
 <references><name>Normative References</name>
  <reference anchor="RFC8126">
   <front>
    <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
    <author></author>
   </front>
   <seriesInfo name='RFC' value='8126'/>
  </reference>
 </references>
 </back>
</rfc>
