<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
  <!-- generated by https://github.com/dthaler/rst2rfcxml version 0.1 -->

<!DOCTYPE rfc [
]>

<?rfc rfcedstyle="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-bpf-isa-02" category="std" submissionType="IETF">
 <front>
  <title abbrev="BPF ISA">
BPF Instruction Set Architecture (ISA)
  </title>
  <author initials="D." surname="Thaler" fullname="Dave Thaler" role="editor">
   <address>
    <postal>
    <city>Redmond</city>
    <code>98052</code>
    <country>USA</country>
    <region>WA</region>
    </postal>
    <email>dave.thaler.ietf@gmail.com</email>
   </address>
  </author>
  <abstract>
   <t>
    This document specifies the BPF instruction set architecture (ISA).
   </t>
  </abstract>
 </front>
 <middle>
  <section anchor="introduction" title="Introduction">
   <t>
    eBPF (which is no longer an acronym for anything), also commonly
    referred to as BPF, is a technology with origins in the Linux kernel
    that can run untrusted programs in a privileged context such as an
    operating system kernel. This document specifies the BPF instruction
    set architecture (ISA).
   </t>
  </section>
  <section anchor="documentation-conventions" title="Documentation conventions">
   <t>
    For brevity and consistency, this document refers to families
    of types using a shorthand syntax and refers to several expository,
    mnemonic functions when describing the semantics of instructions.
    The range of valid values for those types and the semantics of those
    functions are defined in the following subsections.
   </t>
   <section anchor="types" title="Types">
    <t>
     This document refers to integer types with the notation <em>SN</em> to specify
     a type's signedness (<em>S</em>) and bit width (<em>N</em>), respectively.
    </t>
    <table>
     <name>Meaning of signedness notation.</name>
     <thead>
      <tr>
       <th>S</th>
       <th>Meaning</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         u
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         s
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <table>
     <name>Meaning of bit-width notation.</name>
     <thead>
      <tr>
       <th>N</th>
       <th>Bit width</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         8
        </t>
       </td>
       <td>
        <t>
         8 bits
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         16
        </t>
       </td>
       <td>
        <t>
         16 bits
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         32
        </t>
       </td>
       <td>
        <t>
         32 bits
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         64
        </t>
       </td>
       <td>
        <t>
         64 bits
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         128
        </t>
       </td>
       <td>
        <t>
         128 bits
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     For example, <em>u32</em> is a type whose valid values are all the 32-bit unsigned
     numbers and <em>s16</em> is a type whose valid values are all the 16-bit signed
     numbers.
    </t>
   </section>
   <section anchor="functions" title="Functions">
    <ul>
     <li>
      htobe16: Takes an unsigned 16-bit number in host-endian format and
      returns the equivalent number as an unsigned 16-bit number in big-endian
      format.
     </li>
     <li>
      htobe32: Takes an unsigned 32-bit number in host-endian format and
      returns the equivalent number as an unsigned 32-bit number in big-endian
      format.
     </li>
     <li>
      htobe64: Takes an unsigned 64-bit number in host-endian format and
      returns the equivalent number as an unsigned 64-bit number in big-endian
      format.
     </li>
     <li>
      htole16: Takes an unsigned 16-bit number in host-endian format and
      returns the equivalent number as an unsigned 16-bit number in little-endian
      format.
     </li>
     <li>
      htole32: Takes an unsigned 32-bit number in host-endian format and
      returns the equivalent number as an unsigned 32-bit number in little-endian
      format.
     </li>
     <li>
      htole64: Takes an unsigned 64-bit number in host-endian format and
      returns the equivalent number as an unsigned 64-bit number in little-endian
      format.
     </li>
     <li>
      bswap16: Takes an unsigned 16-bit number in either big- or little-endian
      format and returns the equivalent number with the same bit width but
      opposite endianness.
     </li>
     <li>
      bswap32: Takes an unsigned 32-bit number in either big- or little-endian
      format and returns the equivalent number with the same bit width but
      opposite endianness.
     </li>
     <li>
      bswap64: Takes an unsigned 64-bit number in either big- or little-endian
      format and returns the equivalent number with the same bit width but
      opposite endianness.
     </li>
    </ul>
   </section>
   <section anchor="definitions" title="Definitions">
    <dl>
     <dt anchor="term-sign-extend">
      Sign Extend
     </dt>
     <dd>
      <t>
       To <em>sign extend an</em> <tt>X</tt> <em>-bit number, A, to a</em> <tt>Y</tt> <em>-bit number, B  ,</em> means to
      </t>
      <ol>
       <li>
        Copy all <tt>X</tt> bits from <em>A</em> to the lower <tt>X</tt> bits of <em>B</em>.
       </li>
       <li>
        Set the value of the remaining <tt>Y</tt> - <tt>X</tt> bits of <em>B</em> to the value of
        the  most-significant bit of <em>A</em>.
       </li>
      </ol>
     </dd>
    </dl>
    <aside>
     <t><strong>Example</strong></t>
     <t>
      Sign extend an 8-bit number <tt>A</tt> to a 16-bit number <tt>B</tt> on a big-endian platform:
     </t>
     <artwork>
A:          10000110
B: 11111111 10000110
     </artwork>
    </aside>
   </section>
   <section anchor="conformance-groups" title="Conformance groups">
    <t>
     An implementation does not need to support all instructions specified in this
     document (e.g., deprecated instructions).  Instead, a number of conformance
     groups are specified.  An implementation must support the base32 conformance
     group and may support additional conformance groups, where supporting a
     conformance group means it must support all instructions in that conformance
     group.
    </t>
    <t>
     The use of named conformance groups enables interoperability between a runtime
     that executes instructions, and tools such as compilers that generate
     instructions for the runtime.  Thus, capability discovery in terms of
     conformance groups might be done manually by users or automatically by tools.
    </t>
    <t>
     Each conformance group has a short ASCII label (e.g., "base32") that
     corresponds to a set of instructions that are mandatory.  That is, each
     instruction has one or more conformance groups of which it is a member.
    </t>
    <t>
     This document defines the following conformance groups:
    </t>
    <ul>
     <li>
      base32: includes all instructions defined in this
      specification unless otherwise noted.
     </li>
     <li>
      base64: includes base32, plus instructions explicitly noted
      as being in the base64 conformance group.
     </li>
     <li>
      atomic32: includes 32-bit atomic operation instructions (see <xref target="atomic-operations">Atomic operations</xref>).
     </li>
     <li>
      atomic64: includes atomic32, plus 64-bit atomic operation instructions.
     </li>
     <li>
      divmul32: includes 32-bit division, multiplication, and modulo instructions.
     </li>
     <li>
      divmul64: includes divmul32, plus 64-bit division, multiplication,
      and modulo instructions.
     </li>
     <li>
      packet: deprecated packet access instructions.
     </li>
    </ul>
   </section>
  </section>
  <section anchor="instruction-encoding" title="Instruction encoding">
   <t>
    BPF has two instruction encodings:
   </t>
   <ul>
    <li>
     the basic instruction encoding, which uses 64 bits to encode an instruction
    </li>
    <li>
     the wide instruction encoding, which appends a second 64 bits
     after the basic instruction for a total of 128 bits.
    </li>
   </ul>
   <section anchor="basic-instruction-encoding" title="Basic instruction encoding">
    <t>
     A basic instruction is encoded as follows:
    </t>
    <artwork>
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    opcode     |     regs      |            offset             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              imm                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork>
    <dl>
     <dt anchor="term---opcode--">
      <strong>opcode</strong>
     </dt>
     <dd>
      <t>
       operation to perform, encoded as follows:
      </t>
      <artwork>
+-+-+-+-+-+-+-+-+
|specific |class|
+-+-+-+-+-+-+-+-+
      </artwork>
      <dl>
       <dt anchor="term---specific--">
        <strong>specific</strong>
       </dt>
       <dd>
        <t>
         The format of these bits varies by instruction class
        </t>
       </dd>
       <dt anchor="term---class--">
        <strong>class</strong>
       </dt>
       <dd>
        <t>
         The instruction class (see <xref target="instruction-classes">Instruction classes</xref>)
        </t>
       </dd>
      </dl>
     </dd>
     <dt anchor="term---regs--">
      <strong>regs</strong>
     </dt>
     <dd>
      <t>
       The source and destination register numbers, encoded as follows
       on a little-endian host:
      </t>
      <artwork>
+-+-+-+-+-+-+-+-+
|src_reg|dst_reg|
+-+-+-+-+-+-+-+-+
      </artwork>
      <t>
       and as follows on a big-endian host:
      </t>
      <artwork>
+-+-+-+-+-+-+-+-+
|dst_reg|src_reg|
+-+-+-+-+-+-+-+-+
      </artwork>
      <dl>
       <dt anchor="term---src_reg--">
        <strong>src_reg</strong>
       </dt>
       <dd>
        <t>
         the source register number (0-10), except where otherwise specified
         (<xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref> reuse this field for other purposes)
        </t>
       </dd>
       <dt anchor="term---dst_reg--">
        <strong>dst_reg</strong>
       </dt>
       <dd>
        <t>
         destination register number (0-10), unless otherwise specified
         (future instructions might reuse this field for other purposes)
        </t>
       </dd>
      </dl>
     </dd>
     <dt anchor="term---offset--">
      <strong>offset</strong>
     </dt>
     <dd>
      <t>
       signed integer offset used with pointer arithmetic, except where
       otherwise specified (some arithmetic instructions reuse this field
       for other purposes)
      </t>
     </dd>
     <dt anchor="term---imm--">
      <strong>imm</strong>
     </dt>
     <dd>
      <t>
       signed integer immediate value
      </t>
     </dd>
    </dl>
    <t>
     Note that the contents of multi-byte fields ('offset' and 'imm') are
     stored using big-endian byte ordering on big-endian hosts and
     little-endian byte ordering on little-endian hosts.
    </t>
    <t>
     For example:
    </t>
    <artwork>
opcode                  offset imm          assembly
       src_reg dst_reg
07     0       1        00 00  44 33 22 11  r1 += 0x11223344 // little
       dst_reg src_reg
07     1       0        00 00  11 22 33 44  r1 += 0x11223344 // big
    </artwork>
    <t>
     Note that most instructions do not use all of the fields.
     Unused fields shall be cleared to zero.
    </t>
   </section>
   <section anchor="wide-instruction-encoding" title="Wide instruction encoding">
    <t>
     Some instructions are defined to use the wide instruction encoding,
     which uses two 32-bit immediate values.  The 64 bits following
     the basic instruction format contain a pseudo instruction
     with 'opcode', 'dst_reg', 'src_reg', and 'offset' all set to zero.
    </t>
    <t>
     This is depicted in the following figure:
    </t>
    <artwork>
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    opcode     |     regs      |            offset             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                              imm                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           reserved                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           next_imm                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    </artwork>
    <dl>
     <dt anchor="term---opcode---">
      <strong>opcode</strong>
     </dt>
     <dd>
      <t>
       operation to perform, encoded as explained above
      </t>
     </dd>
     <dt anchor="term---regs---">
      <strong>regs</strong>
     </dt>
     <dd>
      <t>
       The source and destination register numbers (unless otherwise
       specified), encoded as explained above
      </t>
     </dd>
     <dt anchor="term---offset---">
      <strong>offset</strong>
     </dt>
     <dd>
      <t>
       signed integer offset used with pointer arithmetic, unless
       otherwise specified
      </t>
     </dd>
     <dt anchor="term---imm---">
      <strong>imm</strong>
     </dt>
     <dd>
      <t>
       signed integer immediate value
      </t>
     </dd>
     <dt anchor="term---reserved--">
      <strong>reserved</strong>
     </dt>
     <dd>
      <t>
       unused, set to zero
      </t>
     </dd>
     <dt anchor="term---next_imm--">
      <strong>next_imm</strong>
     </dt>
     <dd>
      <t>
       second signed integer immediate value
      </t>
     </dd>
    </dl>
   </section>
   <section anchor="instruction-classes" title="Instruction classes">
    <t>
     The three least significant bits of the 'opcode' field store the instruction class:
    </t>
    <table>
     <thead>
      <tr>
       <th>class</th>
       <th>value</th>
       <th>description</th>
       <th>reference</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         LD
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         non-standard load operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         LDX
        </t>
       </td>
       <td>
        <t>
         0x1
        </t>
       </td>
       <td>
        <t>
         load into register operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         ST
        </t>
       </td>
       <td>
        <t>
         0x2
        </t>
       </td>
       <td>
        <t>
         store from immediate operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         STX
        </t>
       </td>
       <td>
        <t>
         0x3
        </t>
       </td>
       <td>
        <t>
         store from register operations
        </t>
       </td>
       <td>
        <t>
         <xref target="load-and-store-instructions">Load and store instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         ALU
        </t>
       </td>
       <td>
        <t>
         0x4
        </t>
       </td>
       <td>
        <t>
         32-bit arithmetic operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JMP
        </t>
       </td>
       <td>
        <t>
         0x5
        </t>
       </td>
       <td>
        <t>
         64-bit jump operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JMP32
        </t>
       </td>
       <td>
        <t>
         0x6
        </t>
       </td>
       <td>
        <t>
         32-bit jump operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         ALU64
        </t>
       </td>
       <td>
        <t>
         0x7
        </t>
       </td>
       <td>
        <t>
         64-bit arithmetic operations
        </t>
       </td>
       <td>
        <t>
         <xref target="arithmetic-and-jump-instructions">Arithmetic and jump instructions</xref>
        </t>
       </td>
      </tr>
     </tbody>
    </table>
   </section>
  </section>
  <section anchor="arithmetic-and-jump-instructions" title="Arithmetic and jump instructions">
   <t>
    For arithmetic and jump instructions (<tt>ALU</tt>, <tt>ALU64</tt>, <tt>JMP</tt> and
    <tt>JMP32</tt>), the 8-bit 'opcode' field is divided into three parts:
   </t>
   <artwork>
+-+-+-+-+-+-+-+-+
|  code |s|class|
+-+-+-+-+-+-+-+-+
   </artwork>
   <dl>
    <dt anchor="term---code--">
     <strong>code</strong>
    </dt>
    <dd>
     <t>
      the operation code, whose meaning varies by instruction class
     </t>
    </dd>
    <dt anchor="term---s--source---">
     <strong>s (source)</strong>
    </dt>
    <dd>
     <t>
      the source operand location, which unless otherwise specified is one of:
     </t>
     <table>
      <thead>
       <tr>
        <th>source</th>
        <th>value</th>
        <th>description</th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
         <t>
          K
         </t>
        </td>
        <td>
         <t>
          0
         </t>
        </td>
        <td>
         <t>
          use 32-bit 'imm' value as source operand
         </t>
        </td>
       </tr>
       <tr>
        <td>
         <t>
          X
         </t>
        </td>
        <td>
         <t>
          1
         </t>
        </td>
        <td>
         <t>
          use 'src_reg' register value as source operand
         </t>
        </td>
       </tr>
      </tbody>
     </table>
    </dd>
    <dt anchor="term---instruction-class--">
     <strong>instruction class</strong>
    </dt>
    <dd>
     <t>
      the instruction class (see <xref target="instruction-classes">Instruction classes</xref>)
     </t>
    </dd>
   </dl>
   <section anchor="arithmetic-instructions" title="Arithmetic instructions">
    <t>
     <tt>ALU</tt> uses 32-bit wide operands while <tt>ALU64</tt> uses 64-bit wide operands for
     otherwise identical operations. <tt>ALU64</tt> instructions belong to the
     base64 conformance group unless noted otherwise.
     The 'code' field encodes the operation as below, where 'src' and 'dst' refer
     to the values of the source and destination registers, respectively.
    </t>
    <table>
     <thead>
      <tr>
       <th>name</th>
       <th>code</th>
       <th>offset</th>
       <th>description</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         ADD
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst += src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         SUB
        </t>
       </td>
       <td>
        <t>
         0x1
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst -= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         MUL
        </t>
       </td>
       <td>
        <t>
         0x2
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst *= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         DIV
        </t>
       </td>
       <td>
        <t>
         0x3
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst = (src != 0) ? (dst / src) : 0
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         SDIV
        </t>
       </td>
       <td>
        <t>
         0x3
        </t>
       </td>
       <td>
        <t>
         1
        </t>
       </td>
       <td>
        <t>
         dst = (src != 0) ? (dst s/ src) : 0
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         OR
        </t>
       </td>
       <td>
        <t>
         0x4
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst |= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         AND
        </t>
       </td>
       <td>
        <t>
         0x5
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst &amp;= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         LSH
        </t>
       </td>
       <td>
        <t>
         0x6
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst &lt;&lt;= (src &amp; mask)
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         RSH
        </t>
       </td>
       <td>
        <t>
         0x7
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst &gt;&gt;= (src &amp; mask)
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         NEG
        </t>
       </td>
       <td>
        <t>
         0x8
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst = -dst
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         MOD
        </t>
       </td>
       <td>
        <t>
         0x9
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst = (src != 0) ? (dst % src) : dst
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         SMOD
        </t>
       </td>
       <td>
        <t>
         0x9
        </t>
       </td>
       <td>
        <t>
         1
        </t>
       </td>
       <td>
        <t>
         dst = (src != 0) ? (dst s% src) : dst
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         XOR
        </t>
       </td>
       <td>
        <t>
         0xa
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst ^= src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         MOV
        </t>
       </td>
       <td>
        <t>
         0xb
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         dst = src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         MOVSX
        </t>
       </td>
       <td>
        <t>
         0xb
        </t>
       </td>
       <td>
        <t>
         8/16/32
        </t>
       </td>
       <td>
        <t>
         dst = (s8,s16,s32)src
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         ARSH
        </t>
       </td>
       <td>
        <t>
         0xc
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         <xref target="term-sign-extend">sign extending</xref> dst &gt;&gt;= (src &amp; mask)
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         END
        </t>
       </td>
       <td>
        <t>
         0xd
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         byte swap operations (see <xref target="byte-swap-instructions">Byte swap instructions</xref> below)
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     Underflow and overflow are allowed during arithmetic operations, meaning
     the 64-bit or 32-bit value will wrap. If BPF program execution would
     result in division by zero, the destination register is instead set to zero.
     If execution would result in modulo by zero, for <tt>ALU64</tt> the value of
     the destination register is unchanged whereas for <tt>ALU</tt> the upper
     32 bits of the destination register are zeroed.
    </t>
    <t>
     <tt>{ADD, X, ALU}</tt>, where 'code' = <tt>ADD</tt>, 'source' = <tt>X</tt>, and 'class' = <tt>ALU</tt>, means:
    </t>
    <artwork>
dst = (u32) ((u32) dst + (u32) src)
    </artwork>
    <t>
     where '(u32)' indicates that the upper 32 bits are zeroed.
    </t>
    <t>
     <tt>{ADD, X, ALU64}</tt> means:
    </t>
    <artwork>
dst = dst + src
    </artwork>
    <t>
     <tt>{XOR, K, ALU}</tt> means:
    </t>
    <artwork>
dst = (u32) dst ^ (u32) imm
    </artwork>
    <t>
     <tt>{XOR, K, ALU64}</tt> means:
    </t>
    <artwork>
dst = dst ^ imm
    </artwork>
    <t>
     Note that most arithmetic instructions have 'offset' set to 0. Only three instructions
     (<tt>SDIV</tt>, <tt>SMOD</tt>, <tt>MOVSX</tt>) have a non-zero 'offset'.
    </t>
    <t>
     Division, multiplication, and modulo operations for <tt>ALU</tt> are part
     of the "divmul32" conformance group, and division, multiplication, and
     modulo operations for <tt>ALU64</tt> are part of the "divmul64" conformance
     group.
     The division and modulo operations support both unsigned and signed flavors.
    </t>
    <t>
     For unsigned operations (<tt>DIV</tt> and <tt>MOD</tt>), for <tt>ALU</tt>,
     'imm' is interpreted as a 32-bit unsigned value. For <tt>ALU64</tt>,
     'imm' is first <xref target="term-sign-extend">sign extended</xref> from 32 to 64 bits, and then
     interpreted as a 64-bit unsigned value.
    </t>
    <t>
     For signed operations (<tt>SDIV</tt> and <tt>SMOD</tt>), for <tt>ALU</tt>,
     'imm' is interpreted as a 32-bit signed value. For <tt>ALU64</tt>, 'imm'
     is first <xref target="term-sign-extend">sign extended</xref> from 32 to 64 bits, and then
     interpreted as a 64-bit signed value.
    </t>
    <t>
     Note that there are varying definitions of the signed modulo operation
     when the dividend or divisor are negative, where implementations often
     vary by language such that Python, Ruby, etc.  differ from C, Go, Java,
     etc. This specification requires that signed modulo use truncated division
     (where -13 % 3 == -1) as implemented in C, Go, etc.:
    </t>
    <artwork>
a % n = a - n * trunc(a / n)
    </artwork>
    <t>
     The <tt>MOVSX</tt> instruction does a move operation with sign extension.
     <tt>{MOVSX, X, ALU}</tt> <xref target="term-sign-extend">sign extends</xref> 8-bit and 16-bit operands into
     32-bit operands, and zeroes the remaining upper 32 bits.
     <tt>{MOVSX, X, ALU64}</tt> <xref target="term-sign-extend">sign extends</xref> 8-bit, 16-bit, and 32-bit
     operands into 64-bit operands.  Unlike other arithmetic instructions,
     <tt>MOVSX</tt> is only defined for register source operands (<tt>X</tt>).
    </t>
    <t>
     The <tt>NEG</tt> instruction is only defined when the source bit is clear
     (<tt>K</tt>).
    </t>
    <t>
     Shift operations use a mask of 0x3F (63) for 64-bit operations and 0x1F (31)
     for 32-bit operations.
    </t>
   </section>
   <section anchor="byte-swap-instructions" title="Byte swap instructions">
    <t>
     The byte swap instructions use instruction classes of <tt>ALU</tt> and <tt>ALU64</tt>
     and a 4-bit 'code' field of <tt>END</tt>.
    </t>
    <t>
     The byte swap instructions operate on the destination register
     only and do not use a separate source register or immediate value.
    </t>
    <t>
     For <tt>ALU</tt>, the 1-bit source operand field in the opcode is used to
     select what byte order the operation converts from or to. For
     <tt>ALU64</tt>, the 1-bit source operand field in the opcode is reserved
     and must be set to 0.
    </t>
    <table>
     <thead>
      <tr>
       <th>class</th>
       <th>source</th>
       <th>value</th>
       <th>description</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         ALU
        </t>
       </td>
       <td>
        <t>
         TO_LE
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         convert between host byte order and little endian
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         ALU
        </t>
       </td>
       <td>
        <t>
         TO_BE
        </t>
       </td>
       <td>
        <t>
         1
        </t>
       </td>
       <td>
        <t>
         convert between host byte order and big endian
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         ALU64
        </t>
       </td>
       <td>
        <t>
         Reserved
        </t>
       </td>
       <td>
        <t>
         0
        </t>
       </td>
       <td>
        <t>
         do byte swap unconditionally
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     The 'imm' field encodes the width of the swap operations.  The following widths
     are supported: 16, 32 and 64.  Width 64 operations belong to the base64
     conformance group and other swap operations belong to the base32
     conformance group.
    </t>
    <t>
     Examples:
    </t>
    <t>
     <tt>{END, TO_LE, ALU}</tt> with 'imm' = 16/32/64 means:
    </t>
    <artwork>
dst = htole16(dst)
dst = htole32(dst)
dst = htole64(dst)
    </artwork>
    <t>
     <tt>{END, TO_BE, ALU}</tt> with 'imm' = 16/32/64 means:
    </t>
    <artwork>
dst = htobe16(dst)
dst = htobe32(dst)
dst = htobe64(dst)
    </artwork>
    <t>
     <tt>{END, TO_LE, ALU64}</tt> with 'imm' = 16/32/64 means:
    </t>
    <artwork>
dst = bswap16(dst)
dst = bswap32(dst)
dst = bswap64(dst)
    </artwork>
   </section>
   <section anchor="jump-instructions" title="Jump instructions">
    <t>
     <tt>JMP32</tt> uses 32-bit wide operands and indicates the base32
     conformance group, while <tt>JMP</tt> uses 64-bit wide operands for
     otherwise identical operations, and indicates the base64 conformance
     group unless otherwise specified.
     The 'code' field encodes the operation as below:
    </t>
    <table>
     <thead>
      <tr>
       <th>code</th>
       <th>value</th>
       <th>src_reg</th>
       <th>description</th>
       <th>notes</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         JA
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         PC += offset
        </t>
       </td>
       <td>
        <t>
         {JA, K, JMP} only
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JA
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         PC += imm
        </t>
       </td>
       <td>
        <t>
         {JA, K, JMP32} only
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JEQ
        </t>
       </td>
       <td>
        <t>
         0x1
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst == src
        </t>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JGT
        </t>
       </td>
       <td>
        <t>
         0x2
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt; src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JGE
        </t>
       </td>
       <td>
        <t>
         0x3
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt;= src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JSET
        </t>
       </td>
       <td>
        <t>
         0x4
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &amp; src
        </t>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JNE
        </t>
       </td>
       <td>
        <t>
         0x5
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst != src
        </t>
       </td>
       <td>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JSGT
        </t>
       </td>
       <td>
        <t>
         0x6
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt; src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JSGE
        </t>
       </td>
       <td>
        <t>
         0x7
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &gt;= src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         CALL
        </t>
       </td>
       <td>
        <t>
         0x8
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         call helper function by static ID
        </t>
       </td>
       <td>
        <t>
         {CALL, K, JMP} only, see <xref target="helper-functions">Helper functions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         CALL
        </t>
       </td>
       <td>
        <t>
         0x8
        </t>
       </td>
       <td>
        <t>
         0x1
        </t>
       </td>
       <td>
        <t>
         call PC += imm
        </t>
       </td>
       <td>
        <t>
         {CALL, K, JMP} only, see <xref target="program-local-functions">Program-local functions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         CALL
        </t>
       </td>
       <td>
        <t>
         0x8
        </t>
       </td>
       <td>
        <t>
         0x2
        </t>
       </td>
       <td>
        <t>
         call helper function by BTF ID
        </t>
       </td>
       <td>
        <t>
         {CALL, K, JMP} only, see <xref target="helper-functions">Helper functions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         EXIT
        </t>
       </td>
       <td>
        <t>
         0x9
        </t>
       </td>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         return
        </t>
       </td>
       <td>
        <t>
         {CALL, K, JMP} only
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JLT
        </t>
       </td>
       <td>
        <t>
         0xa
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt; src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JLE
        </t>
       </td>
       <td>
        <t>
         0xb
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt;= src
        </t>
       </td>
       <td>
        <t>
         unsigned
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JSLT
        </t>
       </td>
       <td>
        <t>
         0xc
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt; src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         JSLE
        </t>
       </td>
       <td>
        <t>
         0xd
        </t>
       </td>
       <td>
        <t>
         any
        </t>
       </td>
       <td>
        <t>
         PC += offset if dst &lt;= src
        </t>
       </td>
       <td>
        <t>
         signed
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     where 'PC' denotes the program counter, and the offset to increment by
     is in units of 64-bit instructions relative to the instruction following
     the jump instruction.  Thus 'PC += 1' skips execution of the next
     instruction if it's a basic instruction or results in undefined behavior
     if the next instruction is a 128-bit wide instruction.
    </t>
    <t>
     The BPF program needs to store the return value into register R0 before doing an
     <tt>EXIT</tt>.
    </t>
    <t>
     Example:
    </t>
    <t>
     <tt>{JSGE, X, JMP32}</tt> means:
    </t>
    <artwork>
if (s32)dst s&gt;= (s32)src goto +offset
    </artwork>
    <t>
     where 's&gt;=' indicates a signed '&gt;=' comparison.
    </t>
    <t>
     <tt>{JA, K, JMP32}</tt> means:
    </t>
    <artwork>
gotol +imm
    </artwork>
    <t>
     where 'imm' means the branch offset comes from the 'imm' field.
    </t>
    <t>
     Note that there are two flavors of <tt>JA</tt> instructions. The
     <tt>JMP</tt> class permits a 16-bit jump offset specified by the 'offset'
     field, whereas the <tt>JMP32</tt> class permits a 32-bit jump offset
     specified by the 'imm' field. A &gt; 16-bit conditional jump may be
     converted to a &lt; 16-bit conditional jump plus a 32-bit unconditional
     jump.
    </t>
    <t>
     All <tt>CALL</tt> and <tt>JA</tt> instructions belong to the
     base32 conformance group.
    </t>
    <section anchor="helper-functions" title="Helper functions">
     <t>
      Helper functions are a concept whereby BPF programs can call into a
      set of function calls exposed by the underlying platform.
     </t>
     <t>
      Historically, each helper function was identified by a static ID
      encoded in the 'imm' field.  The available helper functions may differ
      for each program type, but static IDs are unique across all program types.
     </t>
     <t>
      Platforms that support the BPF Type Format (BTF) support identifying
      a helper function by a BTF ID encoded in the 'imm' field, where the BTF ID
      identifies the helper name and type.
     </t>
    </section>
    <section anchor="program-local-functions" title="Program-local functions">
     <t>
      Program-local functions are functions exposed by the same BPF program as the
      caller, and are referenced by offset from the call instruction, similar to
      <tt>JA</tt>.  The offset is encoded in the 'imm' field of the call instruction.
      An <tt>EXIT</tt> within the program-local function will return to the caller.
     </t>
    </section>
   </section>
  </section>
  <section anchor="load-and-store-instructions" title="Load and store instructions">
   <t>
    For load and store instructions (<tt>LD</tt>, <tt>LDX</tt>, <tt>ST</tt>, and <tt>STX</tt>), the
    8-bit 'opcode' field is divided as follows:
   </t>
   <artwork>
+-+-+-+-+-+-+-+-+
|mode |sz |class|
+-+-+-+-+-+-+-+-+
   </artwork>
   <dl>
    <dt anchor="term---mode--">
     <strong>mode</strong>
    </dt>
    <dd>
     <t>
      The mode modifier is one of:
     </t>
     <table>
      <thead>
       <tr>
        <th>mode modifier</th>
        <th>value</th>
        <th>description</th>
        <th>reference</th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
         <t>
          IMM
         </t>
        </td>
        <td>
         <t>
          0
         </t>
        </td>
        <td>
         <t>
          64-bit immediate instructions
         </t>
        </td>
        <td>
         <t>
          <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
         </t>
        </td>
       </tr>
       <tr>
        <td>
         <t>
          ABS
         </t>
        </td>
        <td>
         <t>
          1
         </t>
        </td>
        <td>
         <t>
          legacy BPF packet access (absolute)
         </t>
        </td>
        <td>
         <t>
          <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
         </t>
        </td>
       </tr>
       <tr>
        <td>
         <t>
          IND
         </t>
        </td>
        <td>
         <t>
          2
         </t>
        </td>
        <td>
         <t>
          legacy BPF packet access (indirect)
         </t>
        </td>
        <td>
         <t>
          <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
         </t>
        </td>
       </tr>
       <tr>
        <td>
         <t>
          MEM
         </t>
        </td>
        <td>
         <t>
          3
         </t>
        </td>
        <td>
         <t>
          regular load and store operations
         </t>
        </td>
        <td>
         <t>
          <xref target="regular-load-and-store-operations">Regular load and store operations</xref>
         </t>
        </td>
       </tr>
       <tr>
        <td>
         <t>
          MEMSX
         </t>
        </td>
        <td>
         <t>
          4
         </t>
        </td>
        <td>
         <t>
          sign-extension load operations
         </t>
        </td>
        <td>
         <t>
          <xref target="sign-extension-load-operations">Sign-extension load operations</xref>
         </t>
        </td>
       </tr>
       <tr>
        <td>
         <t>
          ATOMIC
         </t>
        </td>
        <td>
         <t>
          6
         </t>
        </td>
        <td>
         <t>
          atomic operations
         </t>
        </td>
        <td>
         <t>
          <xref target="atomic-operations">Atomic operations</xref>
         </t>
        </td>
       </tr>
      </tbody>
     </table>
    </dd>
    <dt anchor="term---sz--size---">
     <strong>sz (size)</strong>
    </dt>
    <dd>
     <t>
      The size modifier is one of:
     </t>
     <table>
      <thead>
       <tr>
        <th>size</th>
        <th>value</th>
        <th>description</th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td>
         <t>
          W
         </t>
        </td>
        <td>
         <t>
          0
         </t>
        </td>
        <td>
         <t>
          word        (4 bytes)
         </t>
        </td>
       </tr>
       <tr>
        <td>
         <t>
          H
         </t>
        </td>
        <td>
         <t>
          1
         </t>
        </td>
        <td>
         <t>
          half word   (2 bytes)
         </t>
        </td>
       </tr>
       <tr>
        <td>
         <t>
          B
         </t>
        </td>
        <td>
         <t>
          2
         </t>
        </td>
        <td>
         <t>
          byte
         </t>
        </td>
       </tr>
       <tr>
        <td>
         <t>
          DW
         </t>
        </td>
        <td>
         <t>
          3
         </t>
        </td>
        <td>
         <t>
          double word (8 bytes)
         </t>
        </td>
       </tr>
      </tbody>
     </table>
     <t>
      Instructions using <tt>DW</tt> belong to the base64 conformance group.
     </t>
    </dd>
    <dt anchor="term---class---">
     <strong>class</strong>
    </dt>
    <dd>
     <t>
      The instruction class (see <xref target="instruction-classes">Instruction classes</xref>)
     </t>
    </dd>
   </dl>
   <section anchor="regular-load-and-store-operations" title="Regular load and store operations">
    <t>
     The <tt>MEM</tt> mode modifier is used to encode regular load and store
     instructions that transfer data between a register and memory.
    </t>
    <t>
     <tt>{MEM, &lt;size&gt;, STX}</tt> means:
    </t>
    <artwork>
*(size *) (dst + offset) = src
    </artwork>
    <t>
     <tt>{MEM, &lt;size&gt;, ST}</tt> means:
    </t>
    <artwork>
*(size *) (dst + offset) = imm
    </artwork>
    <t>
     <tt>{MEM, &lt;size&gt;, LDX}</tt> means:
    </t>
    <artwork>
dst = *(unsigned size *) (src + offset)
    </artwork>
    <t>
     Where '&lt;size&gt;' is one of: <tt>B</tt>, <tt>H</tt>, <tt>W</tt>, or <tt>DW</tt>, and
     'unsigned size' is one of: u8, u16, u32, or u64.
    </t>
   </section>
   <section anchor="sign-extension-load-operations" title="Sign-extension load operations">
    <t>
     The <tt>MEMSX</tt> mode modifier is used to encode <xref target="term-sign-extend">sign-extension</xref> load
     instructions that transfer data between a register and memory.
    </t>
    <t>
     <tt>{MEMSX, &lt;size&gt;, LDX}</tt> means:
    </t>
    <artwork>
dst = *(signed size *) (src + offset)
    </artwork>
    <t>
     Where '&lt;size&gt;' is one of: <tt>B</tt>, <tt>H</tt>, or <tt>W</tt>, and
     'signed size' is one of: s8, s16, or s32.
    </t>
   </section>
   <section anchor="atomic-operations" title="Atomic operations">
    <t>
     Atomic operations are operations that operate on memory and can not be
     interrupted or corrupted by other access to the same memory region
     by other BPF programs or means outside of this specification.
    </t>
    <t>
     All atomic operations supported by BPF are encoded as store operations
     that use the <tt>ATOMIC</tt> mode modifier as follows:
    </t>
    <ul>
     <li>
      <tt>{ATOMIC, W, STX}</tt> for 32-bit operations, which are
      part of the "atomic32" conformance group.
     </li>
     <li>
      <tt>{ATOMIC, DW, STX}</tt> for 64-bit operations, which are
      part of the "atomic64" conformance group.
     </li>
     <li>
      8-bit and 16-bit wide atomic operations are not supported.
     </li>
    </ul>
    <t>
     The 'imm' field is used to encode the actual atomic operation.
     Simple atomic operation use a subset of the values defined to encode
     arithmetic operations in the 'imm' field to encode the atomic operation:
    </t>
    <table>
     <thead>
      <tr>
       <th>imm</th>
       <th>value</th>
       <th>description</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         ADD
        </t>
       </td>
       <td>
        <t>
         0x00
        </t>
       </td>
       <td>
        <t>
         atomic add
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         OR
        </t>
       </td>
       <td>
        <t>
         0x40
        </t>
       </td>
       <td>
        <t>
         atomic or
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         AND
        </t>
       </td>
       <td>
        <t>
         0x50
        </t>
       </td>
       <td>
        <t>
         atomic and
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         XOR
        </t>
       </td>
       <td>
        <t>
         0xa0
        </t>
       </td>
       <td>
        <t>
         atomic xor
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     <tt>{ATOMIC, W, STX}</tt> with 'imm' = ADD means:
    </t>
    <artwork>
*(u32 *)(dst + offset) += src
    </artwork>
    <t>
     <tt>{ATOMIC, DW, STX}</tt> with 'imm' = ADD means:
    </t>
    <artwork>
*(u64 *)(dst + offset) += src
    </artwork>
    <t>
     In addition to the simple atomic operations, there also is a modifier and
     two complex atomic operations:
    </t>
    <table>
     <thead>
      <tr>
       <th>imm</th>
       <th>value</th>
       <th>description</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         FETCH
        </t>
       </td>
       <td>
        <t>
         0x01
        </t>
       </td>
       <td>
        <t>
         modifier: return old value
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         XCHG
        </t>
       </td>
       <td>
        <t>
         0xe0 | FETCH
        </t>
       </td>
       <td>
        <t>
         atomic exchange
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         CMPXCHG
        </t>
       </td>
       <td>
        <t>
         0xf0 | FETCH
        </t>
       </td>
       <td>
        <t>
         atomic compare and exchange
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     The <tt>FETCH</tt> modifier is optional for simple atomic operations, and
     always set for the complex atomic operations.  If the <tt>FETCH</tt> flag
     is set, then the operation also overwrites <tt>src</tt> with the value that
     was in memory before it was modified.
    </t>
    <t>
     The <tt>XCHG</tt> operation atomically exchanges <tt>src</tt> with the value
     addressed by <tt>dst + offset</tt>.
    </t>
    <t>
     The <tt>CMPXCHG</tt> operation atomically compares the value addressed by
     <tt>dst + offset</tt> with <tt>R0</tt>. If they match, the value addressed by
     <tt>dst + offset</tt> is replaced with <tt>src</tt>. In either case, the
     value that was at <tt>dst + offset</tt> before the operation is zero-extended
     and loaded back to <tt>R0</tt>.
    </t>
   </section>
   <section anchor="-4-bit-immediate-instructions" title="64-bit immediate instructions">
    <t>
     Instructions with the <tt>IMM</tt> 'mode' modifier use the wide instruction
     encoding defined in <xref target="instruction-encoding">Instruction encoding</xref>, and use the 'src_reg' field of the
     basic instruction to hold an opcode subtype.
    </t>
    <t>
     The following table defines a set of <tt>{IMM, DW, LD}</tt> instructions
     with opcode subtypes in the 'src_reg' field, using new terms such as "map"
     defined further below:
    </t>
    <table>
     <thead>
      <tr>
       <th>src_reg</th>
       <th>pseudocode</th>
       <th>imm type</th>
       <th>dst type</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         0x0
        </t>
       </td>
       <td>
        <t>
         dst = (next_imm &lt;&lt; 32) | imm
        </t>
       </td>
       <td>
        <t>
         integer
        </t>
       </td>
       <td>
        <t>
         integer
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         0x1
        </t>
       </td>
       <td>
        <t>
         dst = map_by_fd(imm)
        </t>
       </td>
       <td>
        <t>
         map fd
        </t>
       </td>
       <td>
        <t>
         map
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         0x2
        </t>
       </td>
       <td>
        <t>
         dst = map_val(map_by_fd(imm)) + next_imm
        </t>
       </td>
       <td>
        <t>
         map fd
        </t>
       </td>
       <td>
        <t>
         data address
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         0x3
        </t>
       </td>
       <td>
        <t>
         dst = var_addr(imm)
        </t>
       </td>
       <td>
        <t>
         variable id
        </t>
       </td>
       <td>
        <t>
         data address
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         0x4
        </t>
       </td>
       <td>
        <t>
         dst = code_addr(imm)
        </t>
       </td>
       <td>
        <t>
         integer
        </t>
       </td>
       <td>
        <t>
         code address
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         0x5
        </t>
       </td>
       <td>
        <t>
         dst = map_by_idx(imm)
        </t>
       </td>
       <td>
        <t>
         map index
        </t>
       </td>
       <td>
        <t>
         map
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         0x6
        </t>
       </td>
       <td>
        <t>
         dst = map_val(map_by_idx(imm)) + next_imm
        </t>
       </td>
       <td>
        <t>
         map index
        </t>
       </td>
       <td>
        <t>
         data address
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     where
    </t>
    <ul>
     <li>
      map_by_fd(imm) means to convert a 32-bit file descriptor into an address of a map (see <xref target="maps">Maps</xref>)
     </li>
     <li>
      map_by_idx(imm) means to convert a 32-bit index into an address of a map
     </li>
     <li>
      map_val(map) gets the address of the first value in a given map
     </li>
     <li>
      var_addr(imm) gets the address of a platform variable (see <xref target="platform-variables">Platform Variables</xref>) with a given id
     </li>
     <li>
      code_addr(imm) gets the address of the instruction at a specified relative offset in number of (64-bit) instructions
     </li>
     <li>
      the 'imm type' can be used by disassemblers for display
     </li>
     <li>
      the 'dst type' can be used for verification and JIT compilation purposes
     </li>
    </ul>
    <section anchor="maps" title="Maps">
     <t>
      Maps are shared memory regions accessible by BPF programs on some platforms.
      A map can have various semantics as defined in a separate document, and may or
      may not have a single contiguous memory region, but the 'map_val(map)' is
      currently only defined for maps that do have a single contiguous memory region.
     </t>
     <t>
      Each map can have a file descriptor (fd) if supported by the platform, where
      'map_by_fd(imm)' means to get the map with the specified file descriptor. Each
      BPF program can also be defined to use a set of maps associated with the
      program at load time, and 'map_by_idx(imm)' means to get the map with the given
      index in the set associated with the BPF program containing the instruction.
     </t>
    </section>
    <section anchor="platform-variables" title="Platform Variables">
     <t>
      Platform variables are memory regions, identified by integer ids, exposed by
      the runtime and accessible by BPF programs on some platforms.  The
      'var_addr(imm)' operation means to get the address of the memory region
      identified by the given id.
     </t>
    </section>
   </section>
   <section anchor="legacy-bpf-packet-access-instructions" title="Legacy BPF Packet access instructions">
    <t>
     BPF previously introduced special instructions for access to packet data that were
     carried over from classic BPF. These instructions used an instruction
     class of <tt>LD</tt>, a size modifier of <tt>W</tt>, <tt>H</tt>, or <tt>B</tt>, and a
     mode modifier of <tt>ABS</tt> or <tt>IND</tt>.  The 'dst_reg' and 'offset' fields were
     set to zero, and 'src_reg' was set to zero for <tt>ABS</tt>.  However, these
     instructions are deprecated and should no longer be used.  All legacy packet
     access instructions belong to the "packet" conformance group.
    </t>
   </section>
  </section>
  <section anchor="security-considerations" title="Security Considerations">
   <t>
    BPF programs could use BPF instructions to do malicious things with memory, CPU, networking,
    or other system resources.  This is not fundamentally different from any other type of
    software that may run on a device.  Execution environments should be carefully designed
    to only run BPF programs that are trusted and verified, and sandboxing and privilege level
    separation are key strategies for limiting security and abuse impact.  For example, BPF
    verifiers are well-known and widely deployed and are responsible for ensuring that BPF programs
    will terminate within a reasonable time, only interact with memory in safe ways, adhere to
    platform-specified API contracts, and don't use instructions with undefined behavior.
    This level of verification can often provide a stronger level
    of security assurance than for other software and operating system code.
    While the details are out of scope of this document,
    <xref target="LINUX">Linux</xref> and
    <xref target="PREVAIL">PREVAIL</xref> do provide many details.  Future IETF work will document verifier expectations
    and building blocks for allowing safe execution of untrusted BPF programs.
   </t>
   <t>
    Executing programs using the BPF instruction set also requires either an interpreter or a compiler
    to translate them to hardware processor native instructions. In general, interpreters are considered a
    source of insecurity (e.g., gadgets susceptible to side-channel attacks due to speculative execution)
    whenever one is used in the same memory address space as data with confidentiality
    concerns.  As such, use of a compiler is recommended instead.  Compilers should be audited
    carefully for vulnerabilities to ensure that compilation of a trusted and verified BPF program
    to native processor instructions does not introduce vulnerabilities.
   </t>
   <t>
    Exposing functionality via BPF extends the interface between the component executing the BPF program and the
    component submitting it. Careful consideration of what functionality is exposed and how
    that impacts the security properties desired is required.
   </t>
  </section>
  <section anchor="iana-considerations" title="IANA Considerations">
   <t>
    This document defines two sub-registries.
   </t>
   <section anchor="bpf-instruction-conformance-group-registry" title="BPF Instruction Conformance Group Registry">
    <t>
     This document defines an IANA sub-registry for BPF instruction conformance groups, as follows:
    </t>
    <ul>
     <li>
      Name of the registry: BPF Instruction Conformance Groups
     </li>
     <li>
      Name of the registry group: BPF Instructions
     </li>
     <li>
      Required information for registrations: See <xref target="bpf-instruction-conformance-group-registration-template">BPF Instruction Conformance Group Registration Template</xref>
     </li>
     <li>
      Syntax of registry entries: Each entry has the following fields: name, description, includes, excludes,
      status, and reference. See <xref target="bpf-instruction-conformance-group-registration-template">BPF Instruction Conformance Group Registration Template</xref> for more details.
     </li>
     <li>
      Registration policy (see <xref target="RFC8126" section="4"/> for details):
      <ul>
       <li>
        Permanent: Standards action or IESG Approval
       </li>
       <li>
        Provisional: Specification required
       </li>
       <li>
        Historical: Specification required
       </li>
      </ul>
     </li>
    </ul>
    <t>
     Initial entries in this sub-registry are as follows:
    </t>
    <table>
     <thead>
      <tr>
       <th>name</th>
       <th>description</th>
       <th>includes</th>
       <th>excludes</th>
       <th>status</th>
       <th>reference</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         atomic32
        </t>
       </td>
       <td>
        <t>
         32-bit atomic instructions
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         Permanent
        </t>
       </td>
       <td>
        <t>
         RFCXXX <xref target="atomic-operations">Atomic operations</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         atomic64
        </t>
       </td>
       <td>
        <t>
         64-bit atomic instructions
        </t>
       </td>
       <td>
        <t>
         atomic32
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         Permanent
        </t>
       </td>
       <td>
        <t>
         RFCXXX <xref target="atomic-operations">Atomic operations</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         base32
        </t>
       </td>
       <td>
        <t>
         32-bit base instructions
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         Permanent
        </t>
       </td>
       <td>
        <t>
         RFCXXX
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         base64
        </t>
       </td>
       <td>
        <t>
         64-bit base instructions
        </t>
       </td>
       <td>
        <t>
         base32
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         Permanent
        </t>
       </td>
       <td>
        <t>
         RFCXXX
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         divmul32
        </t>
       </td>
       <td>
        <t>
         32-bit division and modulo
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         Permanent
        </t>
       </td>
       <td>
        <t>
         RFCXXX <xref target="arithmetic-instructions">Arithmetic instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         divmul64
        </t>
       </td>
       <td>
        <t>
         64-bit division and modulo
        </t>
       </td>
       <td>
        <t>
         divmul32
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         Permanent
        </t>
       </td>
       <td>
        <t>
         RFCXXX <xref target="arithmetic-instructions">Arithmetic instructions</xref>
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         packet
        </t>
       </td>
       <td>
        <t>
         Legacy packet instructions
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         Historical
        </t>
       </td>
       <td>
        <t>
         RFCXXX <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     NOTE TO RFC-EDITOR: Upon publication, please replace RFCXXX above with reference to this document.
    </t>
    <section anchor="bpf-instruction-conformance-group-registration-template" title="BPF Instruction Conformance Group Registration Template">
     <t>
      This template describes the fields that must be supplied in a registration request
      suitable for adding to the registry:
     </t>
     <dl>
      <dt anchor="term-name:">
       Name:
      </dt>
      <dd>
       <t>
        Alphanumeric label indicating the name of the conformance group.
       </t>
      </dd>
      <dt anchor="term-description:">
       Description:
      </dt>
      <dd>
       <t>
        Brief description of the conformance group.
       </t>
      </dd>
      <dt anchor="term-includes:">
       Includes:
      </dt>
      <dd>
       <t>
        Any other conformance groups that are included by this group.
       </t>
      </dd>
      <dt anchor="term-excludes:">
       Excludes:
      </dt>
      <dd>
       <t>
        Any other conformance groups that are excluded by this group.
       </t>
      </dd>
      <dt anchor="term-status:">
       Status:
      </dt>
      <dd>
       <t>
        This reflects the status requested and must be one of 'Permanent',
        'Provisional', or 'Historical'.
       </t>
      </dd>
      <dt anchor="term-contact:">
       Contact:
      </dt>
      <dd>
       <t>
        Person (including contact information) to contact for further information.
       </t>
      </dd>
      <dt anchor="term-change-controller:">
       Change controller:
      </dt>
      <dd>
       <t>
        Organization or person (often the author), including contact information,
        authoried to change this.
       </t>
      </dd>
      <dt anchor="term-reference:">
       Reference:
      </dt>
      <dd>
       <t>
        A reference to the defining specification.
        Include full citations for all referenced documents.
        Registration requests for 'Provisional' registration can be
        included in an Internet-Draft; when the documents expire or are
        approved for publication as an RFC, the registration will be
        updated.
       </t>
      </dd>
     </dl>
    </section>
   </section>
   <section anchor="bpf-instruction-set-registry" title="BPF Instruction Set Registry">
    <t>
     This document proposes a new IANA registry for BPF instructions, as follows:
    </t>
    <ul>
     <li>
      Name of the registry: BPF Instruction Set
     </li>
     <li>
      Name of the registry group: BPF Instructions
     </li>
     <li>
      Required information for registrations: See <xref target="bpf-instruction-registration-template">BPF Instruction Registration Template</xref>
     </li>
     <li>
      Syntax of registry entries: Each entry has the following fields: opcode, src, imm, offset, description,
      groups, and reference. See <xref target="bpf-instruction-registration-template">BPF Instruction Registration Template</xref> for more details.
     </li>
     <li>
      Registration policy: New instructions require a new entry in the conformance group
      sub-registry and the same registration policies apply.
     </li>
     <li>
      Initial registrations: See the Appendix. Instructions other than those listed
      as deprecated are Permanent. Any listed as deprecated are Historical.
     </li>
    </ul>
    <section anchor="bpf-instruction-registration-template" title="BPF Instruction Registration Template">
     <t>
      This template describes the fields that must be supplied in a registration request
      suitable for adding to the registry:
     </t>
     <dl>
      <dt anchor="term-opcode:">
       Opcode:
      </dt>
      <dd>
       <t>
        A 1-byte value in hex format indicating the value of the opcode field
       </t>
      </dd>
      <dt anchor="term-src:">
       Src:
      </dt>
      <dd>
       <t>
        Either a numeric value indicating the value of the src field, or "any"
       </t>
      </dd>
      <dt anchor="term-imm:">
       Imm:
      </dt>
      <dd>
       <t>
        Either a value indicating the value of the imm field, or "any"
       </t>
      </dd>
      <dt anchor="term-offset:">
       Offset:
      </dt>
      <dd>
       <t>
        Either a numeric value indicating the value of the offset field, or "any"
       </t>
      </dd>
      <dt anchor="term-description:-">
       Description:
      </dt>
      <dd>
       <t>
        Description of what the instruction does, typically in pseudocode
       </t>
      </dd>
      <dt anchor="term-groups:">
       Groups:
      </dt>
      <dd>
       <t>
        A list of one or more comma-separated conformance groups to which the instruction belongs
       </t>
      </dd>
      <dt anchor="term-contact:-">
       Contact:
      </dt>
      <dd>
       <t>
        Person (including contact information) to contact for further information.
       </t>
      </dd>
      <dt anchor="term-change-controller:-">
       Change controller:
      </dt>
      <dd>
       <t>
        Organization or person (often the author), including contact information,
        authoried to change this.
       </t>
      </dd>
      <dt anchor="term-reference:-">
       Reference:
      </dt>
      <dd>
       <t>
        A reference to the defining specification.
        Include full citations for all referenced documents.
        Registration requests for 'Provisional' registration can be
        included in an Internet-Draft; when the documents expire or are
        approved for publication as an RFC, the registration will be
        updated.
       </t>
      </dd>
     </dl>
    </section>
   </section>
   <section anchor="adding-instructions" title="Adding instructions">
    <t>
     A specification may add additional instructions to the BPF Instruction Set registry.
     Once a conformance group is registered with a set of instructions,
     no further instructions can be added to that conformance group. A specification
     should instead create a new conformance group that includes the original conformance group,
     plus any newly added instructions.  Inclusion of the original conformance group is done
     via the "includes" column of the BPF Instruction Conformance Group Registry, and inclusion
     of newly added instructions is done via the "groups" column of the BPF Instruction Set Registry.
    </t>
    <t>
     For example, consider an existing hypothetical group called "example" with two instructions in it.
     One might add two more instructions by first adding an "examplev2" group to the
     BPF Instruction Conformance Group Registry as follows:
    </t>
    <table>
     <thead>
      <tr>
       <th>name</th>
       <th>description</th>
       <th>includes</th>
       <th>excludes</th>
       <th>status</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         example
        </t>
       </td>
       <td>
        <t>
         Original example instructions
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         Permanent
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         examplev2
        </t>
       </td>
       <td>
        <t>
         Newer set of example instructions
        </t>
       </td>
       <td>
        <t>
         example
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         Permanent
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     And then adding the new instructions into the BPF Instruction Set Registry as follows:
    </t>
    <table>
     <thead>
      <tr>
       <th>opcode</th>
       <th>...</th>
       <th>description</th>
       <th>groups</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         aaa
        </t>
       </td>
       <td>
        <t>
         ...
        </t>
       </td>
       <td>
        <t>
         Original example instruction 1
        </t>
       </td>
       <td>
        <t>
         example
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         bbb
        </t>
       </td>
       <td>
        <t>
         ...
        </t>
       </td>
       <td>
        <t>
         Original example instruction 2
        </t>
       </td>
       <td>
        <t>
         example
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         ccc
        </t>
       </td>
       <td>
        <t>
         ...
        </t>
       </td>
       <td>
        <t>
         Added example instruction 3
        </t>
       </td>
       <td>
        <t>
         examplev2
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         ddd
        </t>
       </td>
       <td>
        <t>
         ...
        </t>
       </td>
       <td>
        <t>
         Added example instruction 4
        </t>
       </td>
       <td>
        <t>
         examplev2
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     Supporting the "examplev2" group thus requires supporting all four example instructions.
    </t>
   </section>
   <section anchor="deprecating-instructions" title="Deprecating instructions">
    <t>
     Deprecating instructions that are part of an existing conformance group can be done by defining a
     new conformance group for the newly deprecated instructions, and defining a new conformance group
     that supersedes the existing conformance group containing the instructions, where the new conformance
     group includes the existing one and excludes the deprecated instruction group.
    </t>
    <t>
     For example, if deprecating an instruction in an existing hypothetical group called "example", two new groups
     ("legacyexample" and "examplev2") might be registered in the BPF Instruction Conformance Group
     Registry as follows:
    </t>
    <table>
     <thead>
      <tr>
       <th>name</th>
       <th>description</th>
       <th>includes</th>
       <th>excludes</th>
       <th>status</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         example
        </t>
       </td>
       <td>
        <t>
         Original example instructions
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         Permanent
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         legacyexample
        </t>
       </td>
       <td>
        <t>
         Legacy example instructions
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         -
        </t>
       </td>
       <td>
        <t>
         Historical
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         examplev2
        </t>
       </td>
       <td>
        <t>
         Example instructions
        </t>
       </td>
       <td>
        <t>
         example
        </t>
       </td>
       <td>
        <t>
         legacyexample
        </t>
       </td>
       <td>
        <t>
         Permanent
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     The BPF Instruction Set Registry entries for the deprecated instructions would then be updated
     to add "legacyexample" to the set of groups for those instructions, as follows:
    </t>
    <table>
     <thead>
      <tr>
       <th>opcode</th>
       <th>...</th>
       <th>description</th>
       <th>groups</th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <t>
         aaa
        </t>
       </td>
       <td>
        <t>
         ...
        </t>
       </td>
       <td>
        <t>
         Good original instruction 1
        </t>
       </td>
       <td>
        <t>
         example
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         bbb
        </t>
       </td>
       <td>
        <t>
         ...
        </t>
       </td>
       <td>
        <t>
         Good original instruction 2
        </t>
       </td>
       <td>
        <t>
         example
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         ccc
        </t>
       </td>
       <td>
        <t>
         ...
        </t>
       </td>
       <td>
        <t>
         Bad original instruction 3
        </t>
       </td>
       <td>
        <t>
         example, legacyexample
        </t>
       </td>
      </tr>
      <tr>
       <td>
        <t>
         ddd
        </t>
       </td>
       <td>
        <t>
         ...
        </t>
       </td>
       <td>
        <t>
         Bad original instruction 4
        </t>
       </td>
       <td>
        <t>
         example, legacyexample
        </t>
       </td>
      </tr>
     </tbody>
    </table>
    <t>
     Finally, updated implementations that dropped support for the deprecated instructions
     would then be able to claim conformance to "examplev2" rather than "example".
    </t>
   </section>
   <section anchor="change-control" title="Change Control">
    <t>
     Registrations can be updated in a registry by the same mechanism as
     required for an initial registration.  In cases where the original
     definition of an entry is contained in an IESG-approved document,
     update of the specification also requires IESG approval.
    </t>
    <t>
     'Provisional' registrations can be updated by the original registrant
     or anyone designated by the original registrant.  In addition, the
     IESG can reassign responsibility for a 'Provisional' registration
     or can request specific changes to an entry.
     This will enable changes to be made to entries where the original
     registrant is out of contact or unwilling or unable to make changes.
    </t>
    <t>
     Transition from 'Provisional' to 'Permanent' status can be requested
     and approved in the same manner as a new 'Permanent' registration.
     Transition from 'Permanent' to 'Historical' status requires IESG
     approval.  Transition from 'Provisional' to 'Historical' can be
     requested by anyone authorized to update the 'Provisional'
     registration.
    </t>
   </section>
  </section>
  <section anchor="acknowledgements" title="Acknowledgements">
   <t>
    This draft was generated from instruction-set.rst in the Linux
    kernel repository, to which a number of other individuals have authored contributions
    over time, including Akhil Raj, Alexei Starovoitov, Brendan Jackman, Christoph Hellwig, Daniel Borkmann,
    Ilya Leoshkevich, Jiong Wang, Jose E. Marchesi, Kosuke Fujimoto,
    Shahab Vahedi, Tiezhu Yang, Will Hawkins, and Zheng Yejian, with review and suggestions by many others including
    Alan Jowett, Andrii Nakryiko, David Vernet, Jim Harris,
    Quentin Monnet, Song Liu, Shung-Hsi Yu, Stanislav Fomichev, Watson Ladd, and Yonghong Song.
   </t>
  </section>
  <section anchor="appendix" title="Appendix">
   <t>
    Initial values for the BPF Instruction sub-registry are given below.
    The descriptions in this table are informative. In case of any discrepancy, the reference
    is authoritative.
   </t>
   <table>
    <thead>
     <tr>
      <th>opcode</th>
      <th>src_reg</th>
      <th>offset</th>
      <th>imm</th>
      <th>description</th>
      <th>groups</th>
      <th>reference</th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (additional immediate value)
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x04
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst + (u32)imm)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x05
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x06
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        goto +imm
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x07
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst += imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x0c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst + (u32)src)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x0f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst += src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x14
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst - (u32)imm)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x15
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst == imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x16
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst == imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x17
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst -= imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (next_imm &lt;&lt; 32) | imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x1
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = map_by_fd(imm)
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x2
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = map_val(map_by_fd(imm)) + next_imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x3
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = var_addr(imm)
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x4
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = code_addr(imm)
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x5
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = map_by_idx(imm)
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x18
       </t>
      </td>
      <td>
       <t>
        0x6
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = map_val(map_by_idx(imm)) + next_imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="-4-bit-immediate-instructions">64-bit immediate instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((u32)dst - (u32)src)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst == src goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst == (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x1f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst -= src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        packet
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x24
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst * imm)
       </t>
      </td>
      <td>
       <t>
        divmul32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x25
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &gt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x26
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x27
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst *= imm
       </t>
      </td>
      <td>
       <t>
        divmul64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x28
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        packet
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst * src)
       </t>
      </td>
      <td>
       <t>
        divmul32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst &gt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt; (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x2f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst *= src
       </t>
      </td>
      <td>
       <t>
        divmul64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x30
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        packet
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x34
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((imm != 0) ? ((u32)dst / (u32)imm) : 0)
       </t>
      </td>
      <td>
       <t>
        divmul32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x34
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((imm != 0) ? ((s32)dst s/ imm) : 0)
       </t>
      </td>
      <td>
       <t>
        divmul32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x35
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &gt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x36
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x37
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (imm != 0) ? (dst / (u32)imm) : 0
       </t>
      </td>
      <td>
       <t>
        divmul64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x37
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (imm != 0) ? (dst s/ imm) : 0
       </t>
      </td>
      <td>
       <t>
        divmul64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((src != 0) ? ((u32)dst / (u32)src) : 0)
       </t>
      </td>
      <td>
       <t>
        divmul32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((src != 0) ? ((s32)dst s/(s32)src) : 0)
       </t>
      </td>
      <td>
       <t>
        divmul32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst &gt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &gt;= (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (src != 0) ? (dst / src) : 0
       </t>
      </td>
      <td>
       <t>
        divmul64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x3f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (src != 0) ? (dst s/ src) : 0
       </t>
      </td>
      <td>
       <t>
        divmul64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        packet
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x44
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst | imm)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x45
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &amp; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x46
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &amp; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x47
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst |= imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x48
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        packet
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst | src)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst &amp; src goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &amp; (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x4f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst |= src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x50
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        (deprecated, implementation-specific)
       </t>
      </td>
      <td>
       <t>
        packet
       </t>
      </td>
      <td>
       <t>
        <xref target="legacy-bpf-packet-access-instructions">Legacy BPF Packet access instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x54
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &amp; imm)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x55
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst != imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x56
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst != imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x57
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst &amp;= imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &amp; src)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst != src goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst != (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x5f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst &amp;= src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x61
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = *(u32 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x62
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u32 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x63
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        *(u32 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x64
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &lt;&lt; imm)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x65
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&gt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x66
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt; (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x67
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst &lt;&lt;= imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x69
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = *(u16 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6a
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u16 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6b
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        *(u16 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &lt;&lt; src)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst s&gt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt; (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x6f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst &lt;&lt;= src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x71
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = *(u8 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x72
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u8 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x73
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        *(u8 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x74
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &gt;&gt; imm)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x75
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&gt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x76
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt;= (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x77
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst &gt;&gt;= imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x79
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = *(u64 *)(src + offset)
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7a
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        *(u64 *)(dst + offset) = imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7b
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        *(u64 *)(dst + offset) = src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="load-and-store-instructions">Load and store instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst &gt;&gt; src)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7d
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst s&gt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7e
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&gt;= (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x7f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst &gt;&gt;= src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x84
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)-dst
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x85
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        call helper function by static ID
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="helper-functions">Helper functions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x85
       </t>
      </td>
      <td>
       <t>
        0x1
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        call PC += imm
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="program-local-functions">Program-local functions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x85
       </t>
      </td>
      <td>
       <t>
        0x2
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        call helper function by BTF ID
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="helper-functions">Helper functions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x87
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = -dst
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x94
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((imm != 0)?((u32)dst % (u32)imm) : dst)
       </t>
      </td>
      <td>
       <t>
        divmul32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x94
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((imm != 0) ? ((s32)dst s% imm) : dst)
       </t>
      </td>
      <td>
       <t>
        divmul32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x95
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        return
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x97
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (imm != 0) ? (dst % (u32)imm) : dst
       </t>
      </td>
      <td>
       <t>
        divmul64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x97
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (imm != 0) ? (dst s% imm) : dst
       </t>
      </td>
      <td>
       <t>
        divmul64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x9c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((src != 0)?((u32)dst % (u32)src) : dst)
       </t>
      </td>
      <td>
       <t>
        divmul32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x9c
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)((src != 0)?((s32)dst s% (s32)src) :dst)
       </t>
      </td>
      <td>
       <t>
        divmul32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x9f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (src != 0) ? (dst % src) : dst
       </t>
      </td>
      <td>
       <t>
        divmul64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0x9f
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        1
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (src != 0) ? (dst s% src) : dst
       </t>
      </td>
      <td>
       <t>
        divmul64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst ^ imm)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &lt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xa7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst ^= imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xac
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst ^ src)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xad
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst &lt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xae
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt; (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xaf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst ^= src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xb4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32) imm
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xb5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst &lt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xb6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xb7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbc
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32) src
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbc
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        8
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32) (s32) (s8) src
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbc
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        16
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32) (s32) (s16) src
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbd
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst &lt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbe
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (u32)dst &lt;= (u32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        8
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (s64) (s8) src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        16
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (s64) (s16) src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xbf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        32
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (s64) (s32) src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        lock *(u32 *)(dst + offset) += src
       </t>
      </td>
      <td>
       <t>
        atomic32
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x01
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_add_32((u32 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        atomic32
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        lock *(u32 *)(dst + offset) |= src
       </t>
      </td>
      <td>
       <t>
        atomic32
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x41
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_or_32((u32 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        atomic32
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x50
       </t>
      </td>
      <td>
       <t>
        lock *(u32 *)(dst + offset) &amp;= src
       </t>
      </td>
      <td>
       <t>
        atomic32
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x51
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_and_32((u32 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        atomic32
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa0
       </t>
      </td>
      <td>
       <t>
        lock *(u32 *)(dst + offset) ^= src
       </t>
      </td>
      <td>
       <t>
        atomic32
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa1
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_xor_32((u32 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        atomic32
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xe1
       </t>
      </td>
      <td>
       <t>
        src = xchg_32((u32 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        atomic32
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc3
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xf1
       </t>
      </td>
      <td>
       <t>
        r0 = cmpxchg_32((u32 *)(dst + offset), r0, src)
       </t>
      </td>
      <td>
       <t>
        atomic32
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst s&gt;&gt; imm)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&lt; imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt; (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xc7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        dst s&gt;&gt;= imm
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xcc
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst = (u32)(dst s&gt;&gt; src)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xcd
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst s&lt; src goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xce
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt; (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xcf
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        dst s&gt;&gt;= src
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="arithmetic-instructions">Arithmetic instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x10
       </t>
      </td>
      <td>
       <t>
        dst = htole16(dst)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        dst = htole32(dst)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd4
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        dst = htole64(dst)
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd5
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if dst s&lt;= imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd6
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt;= (s32)imm goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x10
       </t>
      </td>
      <td>
       <t>
        dst = bswap16(dst)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        dst = bswap32(dst)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xd7
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        dst = bswap64(dst)
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        lock *(u64 *)(dst + offset) += src
       </t>
      </td>
      <td>
       <t>
        atomic64
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x01
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_add_64((u64 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        atomic64
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        lock *(u64 *)(dst + offset) |= src
       </t>
      </td>
      <td>
       <t>
        atomic64
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x41
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_or_64((u64 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        atomic64
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x50
       </t>
      </td>
      <td>
       <t>
        lock *(u64 *)(dst + offset) &amp;= src
       </t>
      </td>
      <td>
       <t>
        atomic64
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x51
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_and_64((u64 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        atomic64
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa0
       </t>
      </td>
      <td>
       <t>
        lock *(u64 *)(dst + offset) ^= src
       </t>
      </td>
      <td>
       <t>
        atomic64
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xa1
       </t>
      </td>
      <td>
       <t>
        src = atomic_fetch_xor_64((u64 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        atomic64
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xe1
       </t>
      </td>
      <td>
       <t>
        src = xchg_64((u64 *)(dst + offset), src)
       </t>
      </td>
      <td>
       <t>
        atomic64
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdb
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0xf1
       </t>
      </td>
      <td>
       <t>
        r0 = cmpxchg_64((u64 *)(dst + offset), r0, src)
       </t>
      </td>
      <td>
       <t>
        atomic64
       </t>
      </td>
      <td>
       <t>
        <xref target="atomic-operations">Atomic operations</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdc
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x10
       </t>
      </td>
      <td>
       <t>
        dst = htobe16(dst)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdc
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x20
       </t>
      </td>
      <td>
       <t>
        dst = htobe32(dst)
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdc
       </t>
      </td>
      <td>
       <t>
        0x0
       </t>
      </td>
      <td>
       <t>
        0
       </t>
      </td>
      <td>
       <t>
        0x40
       </t>
      </td>
      <td>
       <t>
        dst = htobe64(dst)
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="byte-swap-instructions">Byte swap instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xdd
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if dst s&lt;= src goto +offset
       </t>
      </td>
      <td>
       <t>
        base64
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
     <tr>
      <td>
       <t>
        0xde
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        any
       </t>
      </td>
      <td>
       <t>
        0x00
       </t>
      </td>
      <td>
       <t>
        if (s32)dst s&lt;= (s32)src goto +offset
       </t>
      </td>
      <td>
       <t>
        base32
       </t>
      </td>
      <td>
       <t>
        <xref target="jump-instructions">Jump instructions</xref>
       </t>
      </td>
     </tr>
    </tbody>
   </table>
  </section>
 </middle>
 <back>
 <references><name>Normative References</name>
  <reference anchor="RFC8126">
   <front>
    <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
    <author/>
   </front>
   <seriesInfo name='RFC' value='8126'/>
  </reference>
 </references>
 <references><name>Informative References</name>
  <reference anchor="LINUX" target="https://www.kernel.org/doc/html/latest/bpf/verifier.html">
   <front>
    <title>eBPF verifier</title>
    <author/>
   </front>
  </reference>
  <reference anchor="PREVAIL">
   <front>
    <title>Simple and Precise Static Analysis of Untrusted Linux Kernel Extensions</title>
    <author fullname="E. Gershuni" initials="E." surname="Gershuni"/>
    <author fullname="N. Amit" initials="N." surname="Amit"/>
    <author fullname="A. Gurfinkel" initials="A." surname="Gurfinkel"/>
    <author fullname="N. Narodytska" initials="N." surname="Narodytska"/>
    <author fullname="J. Navas" initials="J." surname="Navas"/>
    <author fullname="N. Rinetzky" initials="N." surname="Rinetzky"/>
    <author fullname="L. Ryzhyk" initials="L." surname="Ryzhyk"/>
    <author fullname="M. Sagiv" initials="M." surname="Sagiv"/>
    <date month="June" year="2019"/>
   </front>
   <seriesInfo name='DOI' value='10.1145/3314221.3314590'/>
  </reference>
 </references>
 </back>
</rfc>
