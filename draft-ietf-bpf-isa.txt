



Network Working Group                                     D. Thaler, Ed.
Internet-Draft                                               24 May 2024
Intended status: Standards Track                                        
Expires: 25 November 2024


                 BPF Instruction Set Architecture (ISA)
                         draft-ietf-bpf-isa-02

Abstract

   eBPF (which is no longer an acronym for anything), also commonly
   referred to as BPF, is a technology with origins in the Linux kernel
   that can run untrusted programs in a privileged context such as an
   operating system kernel.  This document specifies the BPF instruction
   set architecture (ISA).

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 25 November 2024.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.




Thaler                  Expires 25 November 2024                [Page 1]

Internet-Draft                   BPF ISA                        May 2024


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Documentation conventions . . . . . . . . . . . . . . . . . .   3
     2.1.  Types . . . . . . . . . . . . . . . . . . . . . . . . . .   3
     2.2.  Functions . . . . . . . . . . . . . . . . . . . . . . . .   4
     2.3.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   4
     2.4.  Conformance groups  . . . . . . . . . . . . . . . . . . .   5
   3.  Instruction encoding  . . . . . . . . . . . . . . . . . . . .   6
     3.1.  Basic instruction encoding  . . . . . . . . . . . . . . .   6
     3.2.  Wide instruction encoding . . . . . . . . . . . . . . . .   7
     3.3.  Instruction classes . . . . . . . . . . . . . . . . . . .   8
   4.  Arithmetic and jump instructions  . . . . . . . . . . . . . .   9
     4.1.  Arithmetic instructions . . . . . . . . . . . . . . . . .   9
     4.2.  Byte swap instructions  . . . . . . . . . . . . . . . . .  12
     4.3.  Jump instructions . . . . . . . . . . . . . . . . . . . .  13
       4.3.1.  Helper functions  . . . . . . . . . . . . . . . . . .  15
       4.3.2.  Program-local functions . . . . . . . . . . . . . . .  16
   5.  Load and store instructions . . . . . . . . . . . . . . . . .  16
     5.1.  Regular load and store operations . . . . . . . . . . . .  17
     5.2.  Sign-extension load operations  . . . . . . . . . . . . .  17
     5.3.  Atomic operations . . . . . . . . . . . . . . . . . . . .  18
     5.4.  64-bit immediate instructions . . . . . . . . . . . . . .  19
       5.4.1.  Maps  . . . . . . . . . . . . . . . . . . . . . . . .  21
       5.4.2.  Platform Variables  . . . . . . . . . . . . . . . . .  21
     5.5.  Legacy BPF Packet access instructions . . . . . . . . . .  21
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  21
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  22
     7.1.  BPF Instruction Conformance Group Registry  . . . . . . .  22
       7.1.1.  BPF Instruction Conformance Group Registration
               Template  . . . . . . . . . . . . . . . . . . . . . .  23
     7.2.  BPF Instruction Set Registry  . . . . . . . . . . . . . .  24
       7.2.1.  BPF Instruction Registration Template . . . . . . . .  25
     7.3.  Adding instructions . . . . . . . . . . . . . . . . . . .  25
     7.4.  Deprecating instructions  . . . . . . . . . . . . . . . .  26
     7.5.  Change Control  . . . . . . . . . . . . . . . . . . . . .  28
   8.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  28
   9.  Appendix  . . . . . . . . . . . . . . . . . . . . . . . . . .  28
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  43
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  43
     10.2.  Informative References . . . . . . . . . . . . . . . . .  43
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  44









Thaler                  Expires 25 November 2024                [Page 2]

Internet-Draft                   BPF ISA                        May 2024


1.  Introduction

   eBPF (which is no longer an acronym for anything), also commonly
   referred to as BPF, is a technology with origins in the Linux kernel
   that can run untrusted programs in a privileged context such as an
   operating system kernel.  This document specifies the BPF instruction
   set architecture (ISA).

2.  Documentation conventions

   For brevity and consistency, this document refers to families of
   types using a shorthand syntax and refers to several expository,
   mnemonic functions when describing the semantics of instructions.
   The range of valid values for those types and the semantics of those
   functions are defined in the following subsections.

2.1.  Types

   This document refers to integer types with the notation _SN_ to
   specify a type's signedness (_S_) and bit width (_N_), respectively.

                               +===+==========+
                               | S | Meaning  |
                               +===+==========+
                               | u | unsigned |
                               +---+----------+
                               | s | signed   |
                               +---+----------+

                             Table 1: Meaning of
                             signedness notation.

                             +=====+===========+
                             | N   | Bit width |
                             +=====+===========+
                             | 8   | 8 bits    |
                             +-----+-----------+
                             | 16  | 16 bits   |
                             +-----+-----------+
                             | 32  | 32 bits   |
                             +-----+-----------+
                             | 64  | 64 bits   |
                             +-----+-----------+
                             | 128 | 128 bits  |
                             +-----+-----------+

                             Table 2: Meaning of
                             bit-width notation.



Thaler                  Expires 25 November 2024                [Page 3]

Internet-Draft                   BPF ISA                        May 2024


   For example, _u32_ is a type whose valid values are all the 32-bit
   unsigned numbers and _s16_ is a type whose valid values are all the
   16-bit signed numbers.

2.2.  Functions

   *  htobe16: Takes an unsigned 16-bit number in host-endian format and
      returns the equivalent number as an unsigned 16-bit number in big-
      endian format.

   *  htobe32: Takes an unsigned 32-bit number in host-endian format and
      returns the equivalent number as an unsigned 32-bit number in big-
      endian format.

   *  htobe64: Takes an unsigned 64-bit number in host-endian format and
      returns the equivalent number as an unsigned 64-bit number in big-
      endian format.

   *  htole16: Takes an unsigned 16-bit number in host-endian format and
      returns the equivalent number as an unsigned 16-bit number in
      little-endian format.

   *  htole32: Takes an unsigned 32-bit number in host-endian format and
      returns the equivalent number as an unsigned 32-bit number in
      little-endian format.

   *  htole64: Takes an unsigned 64-bit number in host-endian format and
      returns the equivalent number as an unsigned 64-bit number in
      little-endian format.

   *  bswap16: Takes an unsigned 16-bit number in either big- or little-
      endian format and returns the equivalent number with the same bit
      width but opposite endianness.

   *  bswap32: Takes an unsigned 32-bit number in either big- or little-
      endian format and returns the equivalent number with the same bit
      width but opposite endianness.

   *  bswap64: Takes an unsigned 64-bit number in either big- or little-
      endian format and returns the equivalent number with the same bit
      width but opposite endianness.

2.3.  Definitions

   Sign Extend  To _sign extend an_ X _-bit number, A, to a_ Y _-bit
      number, B ,_ means to

      1.  Copy all X bits from _A_ to the lower X bits of _B_.



Thaler                  Expires 25 November 2024                [Page 4]

Internet-Draft                   BPF ISA                        May 2024


      2.  Set the value of the remaining Y - X bits of _B_ to the value
          of the most-significant bit of _A_.

      |  *Example*
      |  
      |  Sign extend an 8-bit number A to a 16-bit number B on a big-
      |  endian platform:
      |  
      |     A:          10000110
      |     B: 11111111 10000110

2.4.  Conformance groups

   An implementation does not need to support all instructions specified
   in this document (e.g., deprecated instructions).  Instead, a number
   of conformance groups are specified.  An implementation must support
   the base32 conformance group and may support additional conformance
   groups, where supporting a conformance group means it must support
   all instructions in that conformance group.

   The use of named conformance groups enables interoperability between
   a runtime that executes instructions, and tools such as compilers
   that generate instructions for the runtime.  Thus, capability
   discovery in terms of conformance groups might be done manually by
   users or automatically by tools.

   Each conformance group has a short ASCII label (e.g., "base32") that
   corresponds to a set of instructions that are mandatory.  That is,
   each instruction has one or more conformance groups of which it is a
   member.

   This document defines the following conformance groups:

   *  base32: includes all instructions defined in this specification
      unless otherwise noted.

   *  base64: includes base32, plus instructions explicitly noted as
      being in the base64 conformance group.

   *  atomic32: includes 32-bit atomic operation instructions (see
      Atomic operations (Section 5.3)).

   *  atomic64: includes atomic32, plus 64-bit atomic operation
      instructions.

   *  divmul32: includes 32-bit division, multiplication, and modulo
      instructions.




Thaler                  Expires 25 November 2024                [Page 5]

Internet-Draft                   BPF ISA                        May 2024


   *  divmul64: includes divmul32, plus 64-bit division, multiplication,
      and modulo instructions.

   *  packet: deprecated packet access instructions.

3.  Instruction encoding

   BPF has two instruction encodings:

   *  the basic instruction encoding, which uses 64 bits to encode an
      instruction

   *  the wide instruction encoding, which appends a second 64 bits
      after the basic instruction for a total of 128 bits.

3.1.  Basic instruction encoding

   A basic instruction is encoded as follows:

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    opcode     |     regs      |            offset             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              imm                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   *opcode*  operation to perform, encoded as follows:

      +-+-+-+-+-+-+-+-+
      |specific |class|
      +-+-+-+-+-+-+-+-+

      *specific*  The format of these bits varies by instruction class

      *class*  The instruction class (see Instruction classes
         (Section 3.3))

   *regs*  The source and destination register numbers, encoded as
      follows on a little-endian host:

      +-+-+-+-+-+-+-+-+
      |src_reg|dst_reg|
      +-+-+-+-+-+-+-+-+

      and as follows on a big-endian host:

      +-+-+-+-+-+-+-+-+
      |dst_reg|src_reg|
      +-+-+-+-+-+-+-+-+



Thaler                  Expires 25 November 2024                [Page 6]

Internet-Draft                   BPF ISA                        May 2024


      *src_reg*  the source register number (0-10), except where
         otherwise specified (64-bit immediate instructions
         (Section 5.4) reuse this field for other purposes)

      *dst_reg*  destination register number (0-10), unless otherwise
         specified (future instructions might reuse this field for other
         purposes)

   *offset*  signed integer offset used with pointer arithmetic, except
      where otherwise specified (some arithmetic instructions reuse this
      field for other purposes)

   *imm*  signed integer immediate value

   Note that the contents of multi-byte fields ('offset' and 'imm') are
   stored using big-endian byte ordering on big-endian hosts and little-
   endian byte ordering on little-endian hosts.

   For example:

  opcode                  offset imm          assembly
         src_reg dst_reg
  07     0       1        00 00  44 33 22 11  r1 += 0x11223344 // little
         dst_reg src_reg
  07     1       0        00 00  11 22 33 44  r1 += 0x11223344 // big

   Note that most instructions do not use all of the fields.  Unused
   fields shall be cleared to zero.

3.2.  Wide instruction encoding

   Some instructions are defined to use the wide instruction encoding,
   which uses two 32-bit immediate values.  The 64 bits following the
   basic instruction format contain a pseudo instruction with 'opcode',
   'dst_reg', 'src_reg', and 'offset' all set to zero.

   This is depicted in the following figure:

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    opcode     |     regs      |            offset             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                              imm                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           reserved                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           next_imm                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+




Thaler                  Expires 25 November 2024                [Page 7]

Internet-Draft                   BPF ISA                        May 2024


   *opcode*  operation to perform, encoded as explained above

   *regs*  The source and destination register numbers (unless otherwise
      specified), encoded as explained above

   *offset*  signed integer offset used with pointer arithmetic, unless
      otherwise specified

   *imm*  signed integer immediate value

   *reserved*  unused, set to zero

   *next_imm*  second signed integer immediate value

3.3.  Instruction classes

   The three least significant bits of the 'opcode' field store the
   instruction class:

    +=======+=======+======================+==========================+
    | class | value | description          | reference                |
    +=======+=======+======================+==========================+
    | LD    | 0x0   | non-standard load    | Load and store           |
    |       |       | operations           | instructions (Section 5) |
    +-------+-------+----------------------+--------------------------+
    | LDX   | 0x1   | load into register   | Load and store           |
    |       |       | operations           | instructions (Section 5) |
    +-------+-------+----------------------+--------------------------+
    | ST    | 0x2   | store from immediate | Load and store           |
    |       |       | operations           | instructions (Section 5) |
    +-------+-------+----------------------+--------------------------+
    | STX   | 0x3   | store from register  | Load and store           |
    |       |       | operations           | instructions (Section 5) |
    +-------+-------+----------------------+--------------------------+
    | ALU   | 0x4   | 32-bit arithmetic    | Arithmetic and jump      |
    |       |       | operations           | instructions (Section 4) |
    +-------+-------+----------------------+--------------------------+
    | JMP   | 0x5   | 64-bit jump          | Arithmetic and jump      |
    |       |       | operations           | instructions (Section 4) |
    +-------+-------+----------------------+--------------------------+
    | JMP32 | 0x6   | 32-bit jump          | Arithmetic and jump      |
    |       |       | operations           | instructions (Section 4) |
    +-------+-------+----------------------+--------------------------+
    | ALU64 | 0x7   | 64-bit arithmetic    | Arithmetic and jump      |
    |       |       | operations           | instructions (Section 4) |
    +-------+-------+----------------------+--------------------------+

                                  Table 3



Thaler                  Expires 25 November 2024                [Page 8]

Internet-Draft                   BPF ISA                        May 2024


4.  Arithmetic and jump instructions

   For arithmetic and jump instructions (ALU, ALU64, JMP and JMP32), the
   8-bit 'opcode' field is divided into three parts:

   +-+-+-+-+-+-+-+-+
   |  code |s|class|
   +-+-+-+-+-+-+-+-+

   *code*  the operation code, whose meaning varies by instruction class

   *s (source)*  the source operand location, which unless otherwise
      specified is one of:

        +========+=======+==========================================+
        | source | value | description                              |
        +========+=======+==========================================+
        | K      | 0     | use 32-bit 'imm' value as source operand |
        +--------+-------+------------------------------------------+
        | X      | 1     | use 'src_reg' register value as source   |
        |        |       | operand                                  |
        +--------+-------+------------------------------------------+

                                   Table 4

   *instruction class*  the instruction class (see Instruction classes
      (Section 3.3))

4.1.  Arithmetic instructions

   ALU uses 32-bit wide operands while ALU64 uses 64-bit wide operands
   for otherwise identical operations.  ALU64 instructions belong to the
   base64 conformance group unless noted otherwise.  The 'code' field
   encodes the operation as below, where 'src' and 'dst' refer to the
   values of the source and destination registers, respectively.
















Thaler                  Expires 25 November 2024                [Page 9]

Internet-Draft                   BPF ISA                        May 2024


    +=======+======+=========+=======================================+
    | name  | code | offset  | description                           |
    +=======+======+=========+=======================================+
    | ADD   | 0x0  | 0       | dst += src                            |
    +-------+------+---------+---------------------------------------+
    | SUB   | 0x1  | 0       | dst -= src                            |
    +-------+------+---------+---------------------------------------+
    | MUL   | 0x2  | 0       | dst *= src                            |
    +-------+------+---------+---------------------------------------+
    | DIV   | 0x3  | 0       | dst = (src != 0) ? (dst / src) : 0    |
    +-------+------+---------+---------------------------------------+
    | SDIV  | 0x3  | 1       | dst = (src != 0) ? (dst s/ src) : 0   |
    +-------+------+---------+---------------------------------------+
    | OR    | 0x4  | 0       | dst |= src                            |
    +-------+------+---------+---------------------------------------+
    | AND   | 0x5  | 0       | dst &= src                            |
    +-------+------+---------+---------------------------------------+
    | LSH   | 0x6  | 0       | dst <<= (src & mask)                  |
    +-------+------+---------+---------------------------------------+
    | RSH   | 0x7  | 0       | dst >>= (src & mask)                  |
    +-------+------+---------+---------------------------------------+
    | NEG   | 0x8  | 0       | dst = -dst                            |
    +-------+------+---------+---------------------------------------+
    | MOD   | 0x9  | 0       | dst = (src != 0) ? (dst % src) : dst  |
    +-------+------+---------+---------------------------------------+
    | SMOD  | 0x9  | 1       | dst = (src != 0) ? (dst s% src) : dst |
    +-------+------+---------+---------------------------------------+
    | XOR   | 0xa  | 0       | dst ^= src                            |
    +-------+------+---------+---------------------------------------+
    | MOV   | 0xb  | 0       | dst = src                             |
    +-------+------+---------+---------------------------------------+
    | MOVSX | 0xb  | 8/16/32 | dst = (s8,s16,s32)src                 |
    +-------+------+---------+---------------------------------------+
    | ARSH  | 0xc  | 0       | sign extending (Section 2.3) dst >>=  |
    |       |      |         | (src & mask)                          |
    +-------+------+---------+---------------------------------------+
    | END   | 0xd  | 0       | byte swap operations (see Byte swap   |
    |       |      |         | instructions (Section 4.2) below)     |
    +-------+------+---------+---------------------------------------+

                                 Table 5

   Underflow and overflow are allowed during arithmetic operations,
   meaning the 64-bit or 32-bit value will wrap.  If BPF program
   execution would result in division by zero, the destination register
   is instead set to zero.  If execution would result in modulo by zero,
   for ALU64 the value of the destination register is unchanged whereas
   for ALU the upper 32 bits of the destination register are zeroed.



Thaler                  Expires 25 November 2024               [Page 10]

Internet-Draft                   BPF ISA                        May 2024


   {ADD, X, ALU}, where 'code' = ADD, 'source' = X, and 'class' = ALU,
   means:

   dst = (u32) ((u32) dst + (u32) src)

   where '(u32)' indicates that the upper 32 bits are zeroed.

   {ADD, X, ALU64} means:

   dst = dst + src

   {XOR, K, ALU} means:

   dst = (u32) dst ^ (u32) imm

   {XOR, K, ALU64} means:

   dst = dst ^ imm

   Note that most arithmetic instructions have 'offset' set to 0.  Only
   three instructions (SDIV, SMOD, MOVSX) have a non-zero 'offset'.

   Division, multiplication, and modulo operations for ALU are part of
   the "divmul32" conformance group, and division, multiplication, and
   modulo operations for ALU64 are part of the "divmul64" conformance
   group.  The division and modulo operations support both unsigned and
   signed flavors.

   For unsigned operations (DIV and MOD), for ALU, 'imm' is interpreted
   as a 32-bit unsigned value.  For ALU64, 'imm' is first sign extended
   (Section 2.3) from 32 to 64 bits, and then interpreted as a 64-bit
   unsigned value.

   For signed operations (SDIV and SMOD), for ALU, 'imm' is interpreted
   as a 32-bit signed value.  For ALU64, 'imm' is first sign extended
   (Section 2.3) from 32 to 64 bits, and then interpreted as a 64-bit
   signed value.

   Note that there are varying definitions of the signed modulo
   operation when the dividend or divisor are negative, where
   implementations often vary by language such that Python, Ruby, etc.
   differ from C, Go, Java, etc.  This specification requires that
   signed modulo use truncated division (where -13 % 3 == -1) as
   implemented in C, Go, etc.:

   a % n = a - n * trunc(a / n)





Thaler                  Expires 25 November 2024               [Page 11]

Internet-Draft                   BPF ISA                        May 2024


   The MOVSX instruction does a move operation with sign extension.
   {MOVSX, X, ALU} sign extends (Section 2.3) 8-bit and 16-bit operands
   into 32-bit operands, and zeroes the remaining upper 32 bits.
   {MOVSX, X, ALU64} sign extends (Section 2.3) 8-bit, 16-bit, and
   32-bit operands into 64-bit operands.  Unlike other arithmetic
   instructions, MOVSX is only defined for register source operands (X).

   The NEG instruction is only defined when the source bit is clear (K).

   Shift operations use a mask of 0x3F (63) for 64-bit operations and
   0x1F (31) for 32-bit operations.

4.2.  Byte swap instructions

   The byte swap instructions use instruction classes of ALU and ALU64
   and a 4-bit 'code' field of END.

   The byte swap instructions operate on the destination register only
   and do not use a separate source register or immediate value.

   For ALU, the 1-bit source operand field in the opcode is used to
   select what byte order the operation converts from or to.  For ALU64,
   the 1-bit source operand field in the opcode is reserved and must be
   set to 0.

         +=======+==========+=======+===========================+
         | class | source   | value | description               |
         +=======+==========+=======+===========================+
         | ALU   | TO_LE    | 0     | convert between host byte |
         |       |          |       | order and little endian   |
         +-------+----------+-------+---------------------------+
         | ALU   | TO_BE    | 1     | convert between host byte |
         |       |          |       | order and big endian      |
         +-------+----------+-------+---------------------------+
         | ALU64 | Reserved | 0     | do byte swap              |
         |       |          |       | unconditionally           |
         +-------+----------+-------+---------------------------+

                                 Table 6

   The 'imm' field encodes the width of the swap operations.  The
   following widths are supported: 16, 32 and 64.  Width 64 operations
   belong to the base64 conformance group and other swap operations
   belong to the base32 conformance group.

   Examples:

   {END, TO_LE, ALU} with 'imm' = 16/32/64 means:



Thaler                  Expires 25 November 2024               [Page 12]

Internet-Draft                   BPF ISA                        May 2024


   dst = htole16(dst)
   dst = htole32(dst)
   dst = htole64(dst)

   {END, TO_BE, ALU} with 'imm' = 16/32/64 means:

   dst = htobe16(dst)
   dst = htobe32(dst)
   dst = htobe64(dst)

   {END, TO_LE, ALU64} with 'imm' = 16/32/64 means:

   dst = bswap16(dst)
   dst = bswap32(dst)
   dst = bswap64(dst)

4.3.  Jump instructions

   JMP32 uses 32-bit wide operands and indicates the base32 conformance
   group, while JMP uses 64-bit wide operands for otherwise identical
   operations, and indicates the base64 conformance group unless
   otherwise specified.  The 'code' field encodes the operation as
   below:

   +======+=======+=========+===============+==========================+
   | code | value | src_reg | description   | notes                    |
   +======+=======+=========+===============+==========================+
   | JA   | 0x0   | 0x0     | PC +=         | {JA, K, JMP} only        |
   |      |       |         | offset        |                          |
   +------+-------+---------+---------------+--------------------------+
   | JA   | 0x0   | 0x0     | PC += imm     | {JA, K, JMP32} only      |
   +------+-------+---------+---------------+--------------------------+
   | JEQ  | 0x1   | any     | PC +=         |                          |
   |      |       |         | offset if     |                          |
   |      |       |         | dst == src    |                          |
   +------+-------+---------+---------------+--------------------------+
   | JGT  | 0x2   | any     | PC +=         | unsigned                 |
   |      |       |         | offset if     |                          |
   |      |       |         | dst > src     |                          |
   +------+-------+---------+---------------+--------------------------+
   | JGE  | 0x3   | any     | PC +=         | unsigned                 |
   |      |       |         | offset if     |                          |
   |      |       |         | dst >= src    |                          |
   +------+-------+---------+---------------+--------------------------+
   | JSET | 0x4   | any     | PC +=         |                          |
   |      |       |         | offset if     |                          |
   |      |       |         | dst & src     |                          |
   +------+-------+---------+---------------+--------------------------+



Thaler                  Expires 25 November 2024               [Page 13]

Internet-Draft                   BPF ISA                        May 2024


   | JNE  | 0x5   | any     | PC +=         |                          |
   |      |       |         | offset if     |                          |
   |      |       |         | dst != src    |                          |
   +------+-------+---------+---------------+--------------------------+
   | JSGT | 0x6   | any     | PC +=         | signed                   |
   |      |       |         | offset if     |                          |
   |      |       |         | dst > src     |                          |
   +------+-------+---------+---------------+--------------------------+
   | JSGE | 0x7   | any     | PC +=         | signed                   |
   |      |       |         | offset if     |                          |
   |      |       |         | dst >= src    |                          |
   +------+-------+---------+---------------+--------------------------+
   | CALL | 0x8   | 0x0     | call helper   | {CALL, K, JMP} only, see |
   |      |       |         | function by   | Helper functions         |
   |      |       |         | static ID     | (Section 4.3.1)          |
   +------+-------+---------+---------------+--------------------------+
   | CALL | 0x8   | 0x1     | call PC +=    | {CALL, K, JMP} only, see |
   |      |       |         | imm           | Program-local functions  |
   |      |       |         |               | (Section 4.3.2)          |
   +------+-------+---------+---------------+--------------------------+
   | CALL | 0x8   | 0x2     | call helper   | {CALL, K, JMP} only, see |
   |      |       |         | function by   | Helper functions         |
   |      |       |         | BTF ID        | (Section 4.3.1)          |
   +------+-------+---------+---------------+--------------------------+
   | EXIT | 0x9   | 0x0     | return        | {CALL, K, JMP} only      |
   +------+-------+---------+---------------+--------------------------+
   | JLT  | 0xa   | any     | PC +=         | unsigned                 |
   |      |       |         | offset if     |                          |
   |      |       |         | dst < src     |                          |
   +------+-------+---------+---------------+--------------------------+
   | JLE  | 0xb   | any     | PC +=         | unsigned                 |
   |      |       |         | offset if     |                          |
   |      |       |         | dst <= src    |                          |
   +------+-------+---------+---------------+--------------------------+
   | JSLT | 0xc   | any     | PC +=         | signed                   |
   |      |       |         | offset if     |                          |
   |      |       |         | dst < src     |                          |
   +------+-------+---------+---------------+--------------------------+
   | JSLE | 0xd   | any     | PC +=         | signed                   |
   |      |       |         | offset if     |                          |
   |      |       |         | dst <= src    |                          |
   +------+-------+---------+---------------+--------------------------+

                                  Table 7

   where 'PC' denotes the program counter, and the offset to increment
   by is in units of 64-bit instructions relative to the instruction
   following the jump instruction.  Thus 'PC += 1' skips execution of



Thaler                  Expires 25 November 2024               [Page 14]

Internet-Draft                   BPF ISA                        May 2024


   the next instruction if it's a basic instruction or results in
   undefined behavior if the next instruction is a 128-bit wide
   instruction.

   The BPF program needs to store the return value into register R0
   before doing an EXIT.

   Example:

   {JSGE, X, JMP32} means:

   if (s32)dst s>= (s32)src goto +offset

   where 's>=' indicates a signed '>=' comparison.

   {JA, K, JMP32} means:

   gotol +imm

   where 'imm' means the branch offset comes from the 'imm' field.

   Note that there are two flavors of JA instructions.  The JMP class
   permits a 16-bit jump offset specified by the 'offset' field, whereas
   the JMP32 class permits a 32-bit jump offset specified by the 'imm'
   field.  A > 16-bit conditional jump may be converted to a < 16-bit
   conditional jump plus a 32-bit unconditional jump.

   All CALL and JA instructions belong to the base32 conformance group.

4.3.1.  Helper functions

   Helper functions are a concept whereby BPF programs can call into a
   set of function calls exposed by the underlying platform.

   Historically, each helper function was identified by a static ID
   encoded in the 'imm' field.  The available helper functions may
   differ for each program type, but static IDs are unique across all
   program types.

   Platforms that support the BPF Type Format (BTF) support identifying
   a helper function by a BTF ID encoded in the 'imm' field, where the
   BTF ID identifies the helper name and type.









Thaler                  Expires 25 November 2024               [Page 15]

Internet-Draft                   BPF ISA                        May 2024


4.3.2.  Program-local functions

   Program-local functions are functions exposed by the same BPF program
   as the caller, and are referenced by offset from the call
   instruction, similar to JA.  The offset is encoded in the 'imm' field
   of the call instruction.  An EXIT within the program-local function
   will return to the caller.

5.  Load and store instructions

   For load and store instructions (LD, LDX, ST, and STX), the 8-bit
   'opcode' field is divided as follows:

   +-+-+-+-+-+-+-+-+
   |mode |sz |class|
   +-+-+-+-+-+-+-+-+

   *mode*  The mode modifier is one of:

        +==========+=======+==================+=====================+
        | mode     | value | description      | reference           |
        | modifier |       |                  |                     |
        +==========+=======+==================+=====================+
        | IMM      | 0     | 64-bit immediate | 64-bit immediate    |
        |          |       | instructions     | instructions        |
        |          |       |                  | (Section 5.4)       |
        +----------+-------+------------------+---------------------+
        | ABS      | 1     | legacy BPF       | Legacy BPF Packet   |
        |          |       | packet access    | access instructions |
        |          |       | (absolute)       | (Section 5.5)       |
        +----------+-------+------------------+---------------------+
        | IND      | 2     | legacy BPF       | Legacy BPF Packet   |
        |          |       | packet access    | access instructions |
        |          |       | (indirect)       | (Section 5.5)       |
        +----------+-------+------------------+---------------------+
        | MEM      | 3     | regular load and | Regular load and    |
        |          |       | store operations | store operations    |
        |          |       |                  | (Section 5.1)       |
        +----------+-------+------------------+---------------------+
        | MEMSX    | 4     | sign-extension   | Sign-extension load |
        |          |       | load operations  | operations          |
        |          |       |                  | (Section 5.2)       |
        +----------+-------+------------------+---------------------+
        | ATOMIC   | 6     | atomic           | Atomic operations   |
        |          |       | operations       | (Section 5.3)       |
        +----------+-------+------------------+---------------------+

                                   Table 8



Thaler                  Expires 25 November 2024               [Page 16]

Internet-Draft                   BPF ISA                        May 2024


   *sz (size)*  The size modifier is one of:

                   +======+=======+=======================+
                   | size | value | description           |
                   +======+=======+=======================+
                   | W    | 0     | word (4 bytes)        |
                   +------+-------+-----------------------+
                   | H    | 1     | half word (2 bytes)   |
                   +------+-------+-----------------------+
                   | B    | 2     | byte                  |
                   +------+-------+-----------------------+
                   | DW   | 3     | double word (8 bytes) |
                   +------+-------+-----------------------+

                                   Table 9

      Instructions using DW belong to the base64 conformance group.

   *class*  The instruction class (see Instruction classes
      (Section 3.3))

5.1.  Regular load and store operations

   The MEM mode modifier is used to encode regular load and store
   instructions that transfer data between a register and memory.

   {MEM, <size>, STX} means:

   *(size *) (dst + offset) = src

   {MEM, <size>, ST} means:

   *(size *) (dst + offset) = imm

   {MEM, <size>, LDX} means:

   dst = *(unsigned size *) (src + offset)

   Where '<size>' is one of: B, H, W, or DW, and 'unsigned size' is one
   of: u8, u16, u32, or u64.

5.2.  Sign-extension load operations

   The MEMSX mode modifier is used to encode sign-extension
   (Section 2.3) load instructions that transfer data between a register
   and memory.

   {MEMSX, <size>, LDX} means:



Thaler                  Expires 25 November 2024               [Page 17]

Internet-Draft                   BPF ISA                        May 2024


   dst = *(signed size *) (src + offset)

   Where '<size>' is one of: B, H, or W, and 'signed size' is one of:
   s8, s16, or s32.

5.3.  Atomic operations

   Atomic operations are operations that operate on memory and can not
   be interrupted or corrupted by other access to the same memory region
   by other BPF programs or means outside of this specification.

   All atomic operations supported by BPF are encoded as store
   operations that use the ATOMIC mode modifier as follows:

   *  {ATOMIC, W, STX} for 32-bit operations, which are part of the
      "atomic32" conformance group.

   *  {ATOMIC, DW, STX} for 64-bit operations, which are part of the
      "atomic64" conformance group.

   *  8-bit and 16-bit wide atomic operations are not supported.

   The 'imm' field is used to encode the actual atomic operation.
   Simple atomic operation use a subset of the values defined to encode
   arithmetic operations in the 'imm' field to encode the atomic
   operation:

                       +=====+=======+=============+
                       | imm | value | description |
                       +=====+=======+=============+
                       | ADD | 0x00  | atomic add  |
                       +-----+-------+-------------+
                       | OR  | 0x40  | atomic or   |
                       +-----+-------+-------------+
                       | AND | 0x50  | atomic and  |
                       +-----+-------+-------------+
                       | XOR | 0xa0  | atomic xor  |
                       +-----+-------+-------------+

                                  Table 10

   {ATOMIC, W, STX} with 'imm' = ADD means:

   *(u32 *)(dst + offset) += src

   {ATOMIC, DW, STX} with 'imm' = ADD means:

   *(u64 *)(dst + offset) += src



Thaler                  Expires 25 November 2024               [Page 18]

Internet-Draft                   BPF ISA                        May 2024


   In addition to the simple atomic operations, there also is a modifier
   and two complex atomic operations:

         +=========+==============+=============================+
         | imm     | value        | description                 |
         +=========+==============+=============================+
         | FETCH   | 0x01         | modifier: return old value  |
         +---------+--------------+-----------------------------+
         | XCHG    | 0xe0 | FETCH | atomic exchange             |
         +---------+--------------+-----------------------------+
         | CMPXCHG | 0xf0 | FETCH | atomic compare and exchange |
         +---------+--------------+-----------------------------+

                                 Table 11

   The FETCH modifier is optional for simple atomic operations, and
   always set for the complex atomic operations.  If the FETCH flag is
   set, then the operation also overwrites src with the value that was
   in memory before it was modified.

   The XCHG operation atomically exchanges src with the value addressed
   by dst + offset.

   The CMPXCHG operation atomically compares the value addressed by dst
   + offset with R0.  If they match, the value addressed by dst + offset
   is replaced with src.  In either case, the value that was at dst +
   offset before the operation is zero-extended and loaded back to R0.

5.4.  64-bit immediate instructions

   Instructions with the IMM 'mode' modifier use the wide instruction
   encoding defined in Instruction encoding (Section 3), and use the
   'src_reg' field of the basic instruction to hold an opcode subtype.

   The following table defines a set of {IMM, DW, LD} instructions with
   opcode subtypes in the 'src_reg' field, using new terms such as "map"
   defined further below:














Thaler                  Expires 25 November 2024               [Page 19]

Internet-Draft                   BPF ISA                        May 2024


    +=========+================================+==========+==========+
    | src_reg | pseudocode                     | imm type | dst type |
    +=========+================================+==========+==========+
    | 0x0     | dst = (next_imm << 32) | imm   | integer  | integer  |
    +---------+--------------------------------+----------+----------+
    | 0x1     | dst = map_by_fd(imm)           | map fd   | map      |
    +---------+--------------------------------+----------+----------+
    | 0x2     | dst = map_val(map_by_fd(imm))  | map fd   | data     |
    |         | + next_imm                     |          | address  |
    +---------+--------------------------------+----------+----------+
    | 0x3     | dst = var_addr(imm)            | variable | data     |
    |         |                                | id       | address  |
    +---------+--------------------------------+----------+----------+
    | 0x4     | dst = code_addr(imm)           | integer  | code     |
    |         |                                |          | address  |
    +---------+--------------------------------+----------+----------+
    | 0x5     | dst = map_by_idx(imm)          | map      | map      |
    |         |                                | index    |          |
    +---------+--------------------------------+----------+----------+
    | 0x6     | dst = map_val(map_by_idx(imm)) | map      | data     |
    |         | + next_imm                     | index    | address  |
    +---------+--------------------------------+----------+----------+

                                 Table 12

   where

   *  map_by_fd(imm) means to convert a 32-bit file descriptor into an
      address of a map (see Maps (Section 5.4.1))

   *  map_by_idx(imm) means to convert a 32-bit index into an address of
      a map

   *  map_val(map) gets the address of the first value in a given map

   *  var_addr(imm) gets the address of a platform variable (see
      Platform Variables (Section 5.4.2)) with a given id

   *  code_addr(imm) gets the address of the instruction at a specified
      relative offset in number of (64-bit) instructions

   *  the 'imm type' can be used by disassemblers for display

   *  the 'dst type' can be used for verification and JIT compilation
      purposes






Thaler                  Expires 25 November 2024               [Page 20]

Internet-Draft                   BPF ISA                        May 2024


5.4.1.  Maps

   Maps are shared memory regions accessible by BPF programs on some
   platforms.  A map can have various semantics as defined in a separate
   document, and may or may not have a single contiguous memory region,
   but the 'map_val(map)' is currently only defined for maps that do
   have a single contiguous memory region.

   Each map can have a file descriptor (fd) if supported by the
   platform, where 'map_by_fd(imm)' means to get the map with the
   specified file descriptor.  Each BPF program can also be defined to
   use a set of maps associated with the program at load time, and
   'map_by_idx(imm)' means to get the map with the given index in the
   set associated with the BPF program containing the instruction.

5.4.2.  Platform Variables

   Platform variables are memory regions, identified by integer ids,
   exposed by the runtime and accessible by BPF programs on some
   platforms.  The 'var_addr(imm)' operation means to get the address of
   the memory region identified by the given id.

5.5.  Legacy BPF Packet access instructions

   BPF previously introduced special instructions for access to packet
   data that were carried over from classic BPF.  These instructions
   used an instruction class of LD, a size modifier of W, H, or B, and a
   mode modifier of ABS or IND.  The 'dst_reg' and 'offset' fields were
   set to zero, and 'src_reg' was set to zero for ABS.  However, these
   instructions are deprecated and should no longer be used.  All legacy
   packet access instructions belong to the "packet" conformance group.

6.  Security Considerations

   BPF programs could use BPF instructions to do malicious things with
   memory, CPU, networking, or other system resources.  This is not
   fundamentally different from any other type of software that may run
   on a device.  Execution environments should be carefully designed to
   only run BPF programs that are trusted and verified, and sandboxing
   and privilege level separation are key strategies for limiting
   security and abuse impact.  For example, BPF verifiers are well-known
   and widely deployed and are responsible for ensuring that BPF
   programs will terminate within a reasonable time, only interact with
   memory in safe ways, adhere to platform-specified API contracts, and
   don't use instructions with undefined behavior.  This level of
   verification can often provide a stronger level of security assurance
   than for other software and operating system code.  While the details
   are out of scope of this document, Linux [LINUX] and PREVAIL



Thaler                  Expires 25 November 2024               [Page 21]

Internet-Draft                   BPF ISA                        May 2024


   [PREVAIL] do provide many details.  Future IETF work will document
   verifier expectations and building blocks for allowing safe execution
   of untrusted BPF programs.

   Executing programs using the BPF instruction set also requires either
   an interpreter or a compiler to translate them to hardware processor
   native instructions.  In general, interpreters are considered a
   source of insecurity (e.g., gadgets susceptible to side-channel
   attacks due to speculative execution) whenever one is used in the
   same memory address space as data with confidentiality concerns.  As
   such, use of a compiler is recommended instead.  Compilers should be
   audited carefully for vulnerabilities to ensure that compilation of a
   trusted and verified BPF program to native processor instructions
   does not introduce vulnerabilities.

   Exposing functionality via BPF extends the interface between the
   component executing the BPF program and the component submitting it.
   Careful consideration of what functionality is exposed and how that
   impacts the security properties desired is required.

7.  IANA Considerations

   This document defines two sub-registries.

7.1.  BPF Instruction Conformance Group Registry

   This document defines an IANA sub-registry for BPF instruction
   conformance groups, as follows:

   *  Name of the registry: BPF Instruction Conformance Groups

   *  Name of the registry group: BPF Instructions

   *  Required information for registrations: See BPF Instruction
      Conformance Group Registration Template (Section 7.1.1)

   *  Syntax of registry entries: Each entry has the following fields:
      name, description, includes, excludes, status, and reference.  See
      BPF Instruction Conformance Group Registration Template
      (Section 7.1.1) for more details.

   *  Registration policy (see Section 4 of [RFC8126] for details):

      -  Permanent: Standards action or IESG Approval

      -  Provisional: Specification required

      -  Historical: Specification required



Thaler                  Expires 25 November 2024               [Page 22]

Internet-Draft                   BPF ISA                        May 2024


   Initial entries in this sub-registry are as follows:

   +========+============+========+========+==========+===============+
   |name    |description |includes|excludes|status    | reference     |
   +========+============+========+========+==========+===============+
   |atomic32|32-bit      |-       |-       |Permanent | RFCXXX Atomic |
   |        |atomic      |        |        |          | operations    |
   |        |instructions|        |        |          | (Section 5.3) |
   +--------+------------+--------+--------+----------+---------------+
   |atomic64|64-bit      |atomic32|-       |Permanent | RFCXXX Atomic |
   |        |atomic      |        |        |          | operations    |
   |        |instructions|        |        |          | (Section 5.3) |
   +--------+------------+--------+--------+----------+---------------+
   |base32  |32-bit base |-       |-       |Permanent | RFCXXX        |
   |        |instructions|        |        |          |               |
   +--------+------------+--------+--------+----------+---------------+
   |base64  |64-bit base |base32  |-       |Permanent | RFCXXX        |
   |        |instructions|        |        |          |               |
   +--------+------------+--------+--------+----------+---------------+
   |divmul32|32-bit      |-       |-       |Permanent | RFCXXX        |
   |        |division and|        |        |          | Arithmetic    |
   |        |modulo      |        |        |          | instructions  |
   |        |            |        |        |          | (Section 4.1) |
   +--------+------------+--------+--------+----------+---------------+
   |divmul64|64-bit      |divmul32|-       |Permanent | RFCXXX        |
   |        |division and|        |        |          | Arithmetic    |
   |        |modulo      |        |        |          | instructions  |
   |        |            |        |        |          | (Section 4.1) |
   +--------+------------+--------+--------+----------+---------------+
   |packet  |Legacy      |-       |-       |Historical| RFCXXX Legacy |
   |        |packet      |        |        |          | BPF Packet    |
   |        |instructions|        |        |          | access        |
   |        |            |        |        |          | instructions  |
   |        |            |        |        |          | (Section 5.5) |
   +--------+------------+--------+--------+----------+---------------+

                   Table 13: Initial conformance groups

   NOTE TO RFC-EDITOR: Upon publication, please replace RFCXXX above
   with reference to this document.

7.1.1.  BPF Instruction Conformance Group Registration Template

   This template describes the fields that must be supplied in a
   registration request suitable for adding to the registry:

   Name:  Alphanumeric label indicating the name of the conformance
      group.



Thaler                  Expires 25 November 2024               [Page 23]

Internet-Draft                   BPF ISA                        May 2024


   Description:  Brief description of the conformance group.

   Includes:  Any other conformance groups that are included by this
      group.

   Excludes:  Any other conformance groups that are excluded by this
      group.

   Status:  This reflects the status requested and must be one of
      'Permanent', 'Provisional', or 'Historical'.

   Contact:  Person (including contact information) to contact for
      further information.

   Change controller:  Organization or person (often the author),
      including contact information, authoried to change this.

   Reference:  A reference to the defining specification.  Include full
      citations for all referenced documents.  Registration requests for
      'Provisional' registration can be included in an Internet-Draft;
      when the documents expire or are approved for publication as an
      RFC, the registration will be updated.

7.2.  BPF Instruction Set Registry

   This document proposes a new IANA registry for BPF instructions, as
   follows:

   *  Name of the registry: BPF Instruction Set

   *  Name of the registry group: BPF Instructions

   *  Required information for registrations: See BPF Instruction
      Registration Template (Section 7.2.1)

   *  Syntax of registry entries: Each entry has the following fields:
      opcode, src, imm, offset, description, groups, and reference.  See
      BPF Instruction Registration Template (Section 7.2.1) for more
      details.

   *  Registration policy: New instructions require a new entry in the
      conformance group sub-registry and the same registration policies
      apply.

   *  Initial registrations: See the Appendix.  Instructions other than
      those listed as deprecated are Permanent.  Any listed as
      deprecated are Historical.




Thaler                  Expires 25 November 2024               [Page 24]

Internet-Draft                   BPF ISA                        May 2024


7.2.1.  BPF Instruction Registration Template

   This template describes the fields that must be supplied in a
   registration request suitable for adding to the registry:

   Opcode:  A 1-byte value in hex format indicating the value of the
      opcode field

   Src:  Either a numeric value indicating the value of the src field,
      or "any"

   Imm:  Either a value indicating the value of the imm field, or "any"

   Offset:  Either a numeric value indicating the value of the offset
      field, or "any"

   Description:  Description of what the instruction does, typically in
      pseudocode

   Groups:  A list of one or more comma-separated conformance groups to
      which the instruction belongs

   Contact:  Person (including contact information) to contact for
      further information.

   Change controller:  Organization or person (often the author),
      including contact information, authoried to change this.

   Reference:  A reference to the defining specification.  Include full
      citations for all referenced documents.  Registration requests for
      'Provisional' registration can be included in an Internet-Draft;
      when the documents expire or are approved for publication as an
      RFC, the registration will be updated.

7.3.  Adding instructions

   A specification may add additional instructions to the BPF
   Instruction Set registry.  Once a conformance group is registered
   with a set of instructions, no further instructions can be added to
   that conformance group.  A specification should instead create a new
   conformance group that includes the original conformance group, plus
   any newly added instructions.  Inclusion of the original conformance
   group is done via the "includes" column of the BPF Instruction
   Conformance Group Registry, and inclusion of newly added instructions
   is done via the "groups" column of the BPF Instruction Set Registry.






Thaler                  Expires 25 November 2024               [Page 25]

Internet-Draft                   BPF ISA                        May 2024


   For example, consider an existing hypothetical group called "example"
   with two instructions in it.  One might add two more instructions by
   first adding an "examplev2" group to the BPF Instruction Conformance
   Group Registry as follows:

    +===========+==================+==========+==========+===========+
    | name      | description      | includes | excludes | status    |
    +===========+==================+==========+==========+===========+
    | example   | Original example | -        | -        | Permanent |
    |           | instructions     |          |          |           |
    +-----------+------------------+----------+----------+-----------+
    | examplev2 | Newer set of     | example  | -        | Permanent |
    |           | example          |          |          |           |
    |           | instructions     |          |          |           |
    +-----------+------------------+----------+----------+-----------+

             Table 14: Conformance group example for addition

   And then adding the new instructions into the BPF Instruction Set
   Registry as follows:

       +========+=====+================================+===========+
       | opcode | ... | description                    | groups    |
       +========+=====+================================+===========+
       | aaa    | ... | Original example instruction 1 | example   |
       +--------+-----+--------------------------------+-----------+
       | bbb    | ... | Original example instruction 2 | example   |
       +--------+-----+--------------------------------+-----------+
       | ccc    | ... | Added example instruction 3    | examplev2 |
       +--------+-----+--------------------------------+-----------+
       | ddd    | ... | Added example instruction 4    | examplev2 |
       +--------+-----+--------------------------------+-----------+

                   Table 15: Instruction addition example

   Supporting the "examplev2" group thus requires supporting all four
   example instructions.

7.4.  Deprecating instructions

   Deprecating instructions that are part of an existing conformance
   group can be done by defining a new conformance group for the newly
   deprecated instructions, and defining a new conformance group that
   supersedes the existing conformance group containing the
   instructions, where the new conformance group includes the existing
   one and excludes the deprecated instruction group.





Thaler                  Expires 25 November 2024               [Page 26]

Internet-Draft                   BPF ISA                        May 2024


   For example, if deprecating an instruction in an existing
   hypothetical group called "example", two new groups ("legacyexample"
   and "examplev2") might be registered in the BPF Instruction
   Conformance Group Registry as follows:

   +===============+==============+========+===============+==========+
   | name          | description  |includes| excludes      |status    |
   +===============+==============+========+===============+==========+
   | example       | Original     |-       | -             |Permanent |
   |               | example      |        |               |          |
   |               | instructions |        |               |          |
   +---------------+--------------+--------+---------------+----------+
   | legacyexample | Legacy       |-       | -             |Historical|
   |               | example      |        |               |          |
   |               | instructions |        |               |          |
   +---------------+--------------+--------+---------------+----------+
   | examplev2     | Example      |example | legacyexample |Permanent |
   |               | instructions |        |               |          |
   +---------------+--------------+--------+---------------+----------+

           Table 16: Conformance group example for deprecation

   The BPF Instruction Set Registry entries for the deprecated
   instructions would then be updated to add "legacyexample" to the set
   of groups for those instructions, as follows:

      +========+=====+=============================+===============+
      | opcode | ... | description                 | groups        |
      +========+=====+=============================+===============+
      | aaa    | ... | Good original instruction 1 | example       |
      +--------+-----+-----------------------------+---------------+
      | bbb    | ... | Good original instruction 2 | example       |
      +--------+-----+-----------------------------+---------------+
      | ccc    | ... | Bad original instruction 3  | example,      |
      |        |     |                             | legacyexample |
      +--------+-----+-----------------------------+---------------+
      | ddd    | ... | Bad original instruction 4  | example,      |
      |        |     |                             | legacyexample |
      +--------+-----+-----------------------------+---------------+

                Table 17: Instruction deprecation example

   Finally, updated implementations that dropped support for the
   deprecated instructions would then be able to claim conformance to
   "examplev2" rather than "example".






Thaler                  Expires 25 November 2024               [Page 27]

Internet-Draft                   BPF ISA                        May 2024


7.5.  Change Control

   Registrations can be updated in a registry by the same mechanism as
   required for an initial registration.  In cases where the original
   definition of an entry is contained in an IESG-approved document,
   update of the specification also requires IESG approval.

   'Provisional' registrations can be updated by the original registrant
   or anyone designated by the original registrant.  In addition, the
   IESG can reassign responsibility for a 'Provisional' registration or
   can request specific changes to an entry.  This will enable changes
   to be made to entries where the original registrant is out of contact
   or unwilling or unable to make changes.

   Transition from 'Provisional' to 'Permanent' status can be requested
   and approved in the same manner as a new 'Permanent' registration.
   Transition from 'Permanent' to 'Historical' status requires IESG
   approval.  Transition from 'Provisional' to 'Historical' can be
   requested by anyone authorized to update the 'Provisional'
   registration.

8.  Acknowledgements

   This draft was generated from instruction-set.rst in the Linux kernel
   repository, to which a number of other individuals have authored
   contributions over time, including Akhil Raj, Alexei Starovoitov,
   Brendan Jackman, Christoph Hellwig, Daniel Borkmann, Ilya
   Leoshkevich, Jiong Wang, Jose E.  Marchesi, Kosuke Fujimoto, Shahab
   Vahedi, Tiezhu Yang, Will Hawkins, and Zheng Yejian, with review and
   suggestions by many others including Alan Jowett, Andrii Nakryiko,
   David Vernet, Jim Harris, Quentin Monnet, Song Liu, Shung-Hsi Yu,
   Stanislav Fomichev, Watson Ladd, and Yonghong Song.

9.  Appendix

   Initial values for the BPF Instruction sub-registry are given below.
   The descriptions in this table are informative.  In case of any
   discrepancy, the reference is authoritative.

   +======+=======+======+====+========================+========+=============+
   |opcode|src_reg|offset|imm |description             |groups  |reference    |
   +======+=======+======+====+========================+========+=============+
   |0x00  |0x0    |0     |any |(additional immediate   |base64  |64-bit       |
   |      |       |      |    |value)                  |        |immediate    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.4)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x04  |0x0    |0     |any |dst = (u32)((u32)dst +  |base32  |Arithmetic   |



Thaler                  Expires 25 November 2024               [Page 28]

Internet-Draft                   BPF ISA                        May 2024


   |      |       |      |    |(u32)imm)               |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x05  |0x0    |any   |0x00|goto +offset            |base32  |Jump         |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x06  |0x0    |0     |any |goto +imm               |base32  |Jump         |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x07  |0x0    |0     |any |dst += imm              |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x0c  |any    |0     |0x00|dst = (u32)((u32)dst +  |base32  |Arithmetic   |
   |      |       |      |    |(u32)src)               |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x0f  |any    |0     |0x00|dst += src              |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x14  |0x0    |0     |any |dst = (u32)((u32)dst -  |base32  |Arithmetic   |
   |      |       |      |    |(u32)imm)               |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x15  |0x0    |any   |any |if dst == imm goto      |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x16  |0x0    |any   |any |if (u32)dst == imm goto |base32  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x17  |0x0    |0     |any |dst -= imm              |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x18  |0x0    |0     |any |dst = (next_imm << 32) ||base64  |64-bit       |
   |      |       |      |    |imm                     |        |immediate    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.4)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x18  |0x1    |0     |any |dst = map_by_fd(imm)    |base64  |64-bit       |
   |      |       |      |    |                        |        |immediate    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.4)|



Thaler                  Expires 25 November 2024               [Page 29]

Internet-Draft                   BPF ISA                        May 2024


   +------+-------+------+----+------------------------+--------+-------------+
   |0x18  |0x2    |0     |any |dst =                   |base64  |64-bit       |
   |      |       |      |    |map_val(map_by_fd(imm)) |        |immediate    |
   |      |       |      |    |+ next_imm              |        |instructions |
   |      |       |      |    |                        |        |(Section 5.4)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x18  |0x3    |0     |any |dst = var_addr(imm)     |base64  |64-bit       |
   |      |       |      |    |                        |        |immediate    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.4)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x18  |0x4    |0     |any |dst = code_addr(imm)    |base64  |64-bit       |
   |      |       |      |    |                        |        |immediate    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.4)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x18  |0x5    |0     |any |dst = map_by_idx(imm)   |base64  |64-bit       |
   |      |       |      |    |                        |        |immediate    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.4)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x18  |0x6    |0     |any |dst =                   |base64  |64-bit       |
   |      |       |      |    |map_val(map_by_idx(imm))|        |immediate    |
   |      |       |      |    |+ next_imm              |        |instructions |
   |      |       |      |    |                        |        |(Section 5.4)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x1c  |any    |0     |0x00|dst = (u32)((u32)dst -  |base32  |Arithmetic   |
   |      |       |      |    |(u32)src)               |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x1d  |any    |any   |0x00|if dst == src goto      |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x1e  |any    |any   |0x00|if (u32)dst == (u32)src |base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x1f  |any    |0     |0x00|dst -= src              |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x20  |0x0    |0     |any |(deprecated,            |packet  |Legacy BPF   |
   |      |       |      |    |implementation-specific)|        |Packet access|
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.5)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x24  |0x0    |0     |any |dst = (u32)(dst * imm)  |divmul32|Arithmetic   |



Thaler                  Expires 25 November 2024               [Page 30]

Internet-Draft                   BPF ISA                        May 2024


   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x25  |0x0    |any   |any |if dst > imm goto       |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x26  |0x0    |any   |any |if (u32)dst > imm goto  |base32  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x27  |0x0    |0     |any |dst *= imm              |divmul64|Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x28  |0x0    |0     |any |(deprecated,            |packet  |Legacy BPF   |
   |      |       |      |    |implementation-specific)|        |Packet access|
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.5)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x2c  |any    |0     |0x00|dst = (u32)(dst * src)  |divmul32|Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x2d  |any    |any   |0x00|if dst > src goto       |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x2e  |any    |any   |0x00|if (u32)dst > (u32)src  |base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x2f  |any    |0     |0x00|dst *= src              |divmul64|Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x30  |0x0    |0     |any |(deprecated,            |packet  |Legacy BPF   |
   |      |       |      |    |implementation-specific)|        |Packet access|
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.5)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x34  |0x0    |0     |any |dst = (u32)((imm != 0) ?|divmul32|Arithmetic   |
   |      |       |      |    |((u32)dst / (u32)imm) : |        |instructions |
   |      |       |      |    |0)                      |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x34  |0x0    |1     |any |dst = (u32)((imm != 0) ?|divmul32|Arithmetic   |
   |      |       |      |    |((s32)dst s/ imm) : 0)  |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|



Thaler                  Expires 25 November 2024               [Page 31]

Internet-Draft                   BPF ISA                        May 2024


   +------+-------+------+----+------------------------+--------+-------------+
   |0x35  |0x0    |any   |any |if dst >= imm goto      |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x36  |0x0    |any   |any |if (u32)dst >= imm goto |base32  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x37  |0x0    |0     |any |dst = (imm != 0) ? (dst |divmul64|Arithmetic   |
   |      |       |      |    |/ (u32)imm) : 0         |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x37  |0x0    |1     |any |dst = (imm != 0) ? (dst |divmul64|Arithmetic   |
   |      |       |      |    |s/ imm) : 0             |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x3c  |any    |0     |0x00|dst = (u32)((src != 0) ?|divmul32|Arithmetic   |
   |      |       |      |    |((u32)dst / (u32)src) : |        |instructions |
   |      |       |      |    |0)                      |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x3c  |any    |1     |0x00|dst = (u32)((src != 0) ?|divmul32|Arithmetic   |
   |      |       |      |    |((s32)dst s/(s32)src) : |        |instructions |
   |      |       |      |    |0)                      |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x3d  |any    |any   |0x00|if dst >= src goto      |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x3e  |any    |any   |0x00|if (u32)dst >= (u32)src |base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x3f  |any    |0     |0x00|dst = (src != 0) ? (dst |divmul64|Arithmetic   |
   |      |       |      |    |/ src) : 0              |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x3f  |any    |1     |0x00|dst = (src != 0) ? (dst |divmul64|Arithmetic   |
   |      |       |      |    |s/ src) : 0             |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x40  |any    |0     |any |(deprecated,            |packet  |Legacy BPF   |
   |      |       |      |    |implementation-specific)|        |Packet access|
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.5)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x44  |0x0    |0     |any |dst = (u32)(dst | imm)  |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |



Thaler                  Expires 25 November 2024               [Page 32]

Internet-Draft                   BPF ISA                        May 2024


   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x45  |0x0    |any   |any |if dst & imm goto       |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x46  |0x0    |any   |any |if (u32)dst & imm goto  |base32  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x47  |0x0    |0     |any |dst |= imm              |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x48  |any    |0     |any |(deprecated,            |packet  |Legacy BPF   |
   |      |       |      |    |implementation-specific)|        |Packet access|
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.5)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x4c  |any    |0     |0x00|dst = (u32)(dst | src)  |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x4d  |any    |any   |0x00|if dst & src goto       |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x4e  |any    |any   |0x00|if (u32)dst & (u32)src  |base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x4f  |any    |0     |0x00|dst |= src              |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x50  |any    |0     |any |(deprecated,            |packet  |Legacy BPF   |
   |      |       |      |    |implementation-specific)|        |Packet access|
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5.5)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x54  |0x0    |0     |any |dst = (u32)(dst & imm)  |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x55  |0x0    |any   |any |if dst != imm goto      |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+



Thaler                  Expires 25 November 2024               [Page 33]

Internet-Draft                   BPF ISA                        May 2024


   |0x56  |0x0    |any   |any |if (u32)dst != imm goto |base32  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x57  |0x0    |0     |any |dst &= imm              |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x5c  |any    |0     |0x00|dst = (u32)(dst & src)  |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x5d  |any    |any   |0x00|if dst != src goto      |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x5e  |any    |any   |0x00|if (u32)dst != (u32)src |base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x5f  |any    |0     |0x00|dst &= src              |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x61  |any    |any   |0x00|dst = *(u32 *)(src +    |base32  |Load and     |
   |      |       |      |    |offset)                 |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x62  |0x0    |any   |any |*(u32 *)(dst + offset) =|base32  |Load and     |
   |      |       |      |    |imm                     |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x63  |any    |any   |0x00|*(u32 *)(dst + offset) =|base32  |Load and     |
   |      |       |      |    |src                     |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x64  |0x0    |0     |any |dst = (u32)(dst << imm) |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x65  |0x0    |any   |any |if dst s> imm goto      |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x66  |0x0    |any   |any |if (s32)dst s> (s32)imm |base32  |Jump         |



Thaler                  Expires 25 November 2024               [Page 34]

Internet-Draft                   BPF ISA                        May 2024


   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x67  |0x0    |0     |any |dst <<= imm             |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x69  |any    |any   |0x00|dst = *(u16 *)(src +    |base32  |Load and     |
   |      |       |      |    |offset)                 |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x6a  |0x0    |any   |any |*(u16 *)(dst + offset) =|base32  |Load and     |
   |      |       |      |    |imm                     |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x6b  |any    |any   |0x00|*(u16 *)(dst + offset) =|base32  |Load and     |
   |      |       |      |    |src                     |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x6c  |any    |0     |0x00|dst = (u32)(dst << src) |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x6d  |any    |any   |0x00|if dst s> src goto      |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x6e  |any    |any   |0x00|if (s32)dst s> (s32)src |base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x6f  |any    |0     |0x00|dst <<= src             |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x71  |any    |any   |0x00|dst = *(u8 *)(src +     |base32  |Load and     |
   |      |       |      |    |offset)                 |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x72  |0x0    |any   |any |*(u8 *)(dst + offset) = |base32  |Load and     |
   |      |       |      |    |imm                     |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+



Thaler                  Expires 25 November 2024               [Page 35]

Internet-Draft                   BPF ISA                        May 2024


   |0x73  |any    |any   |0x00|*(u8 *)(dst + offset) = |base32  |Load and     |
   |      |       |      |    |src                     |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x74  |0x0    |0     |any |dst = (u32)(dst >> imm) |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x75  |0x0    |any   |any |if dst s>= imm goto     |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x76  |0x0    |any   |any |if (s32)dst s>= (s32)imm|base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x77  |0x0    |0     |any |dst >>= imm             |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x79  |any    |any   |0x00|dst = *(u64 *)(src +    |base64  |Load and     |
   |      |       |      |    |offset)                 |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x7a  |0x0    |any   |any |*(u64 *)(dst + offset) =|base64  |Load and     |
   |      |       |      |    |imm                     |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x7b  |any    |any   |0x00|*(u64 *)(dst + offset) =|base64  |Load and     |
   |      |       |      |    |src                     |        |store        |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 5)  |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x7c  |any    |0     |0x00|dst = (u32)(dst >> src) |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x7d  |any    |any   |0x00|if dst s>= src goto     |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x7e  |any    |any   |0x00|if (s32)dst s>= (s32)src|base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+



Thaler                  Expires 25 November 2024               [Page 36]

Internet-Draft                   BPF ISA                        May 2024


   |0x7f  |any    |0     |0x00|dst >>= src             |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x84  |0x0    |0     |0x00|dst = (u32)-dst         |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x85  |0x0    |0     |any |call helper function by |base32  |Helper       |
   |      |       |      |    |static ID               |        |functions    |
   |      |       |      |    |                        |        |(Section     |
   |      |       |      |    |                        |        |4.3.1)       |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x85  |0x1    |0     |any |call PC += imm          |base32  |Program-local|
   |      |       |      |    |                        |        |functions    |
   |      |       |      |    |                        |        |(Section     |
   |      |       |      |    |                        |        |4.3.2)       |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x85  |0x2    |0     |any |call helper function by |base32  |Helper       |
   |      |       |      |    |BTF ID                  |        |functions    |
   |      |       |      |    |                        |        |(Section     |
   |      |       |      |    |                        |        |4.3.1)       |
   +------+-------+------+----+------------------------+--------+-------------+
   |0x87  |0x0    |0     |0x00|dst = -dst              |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x94  |0x0    |0     |any |dst = (u32)((imm !=     |divmul32|Arithmetic   |
   |      |       |      |    |0)?((u32)dst % (u32)imm)|        |instructions |
   |      |       |      |    |: dst)                  |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x94  |0x0    |1     |any |dst = (u32)((imm != 0) ?|divmul32|Arithmetic   |
   |      |       |      |    |((s32)dst s% imm) : dst)|        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x95  |0x0    |0     |0x00|return                  |base32  |Jump         |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x97  |0x0    |0     |any |dst = (imm != 0) ? (dst |divmul64|Arithmetic   |
   |      |       |      |    |% (u32)imm) : dst       |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x97  |0x0    |1     |any |dst = (imm != 0) ? (dst |divmul64|Arithmetic   |
   |      |       |      |    |s% imm) : dst           |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x9c  |any    |0     |0x00|dst = (u32)((src !=     |divmul32|Arithmetic   |



Thaler                  Expires 25 November 2024               [Page 37]

Internet-Draft                   BPF ISA                        May 2024


   |      |       |      |    |0)?((u32)dst % (u32)src)|        |instructions |
   |      |       |      |    |: dst)                  |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x9c  |any    |1     |0x00|dst = (u32)((src !=     |divmul32|Arithmetic   |
   |      |       |      |    |0)?((s32)dst s%         |        |instructions |
   |      |       |      |    |(s32)src) :dst)         |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x9f  |any    |0     |0x00|dst = (src != 0) ? (dst |divmul64|Arithmetic   |
   |      |       |      |    |% src) : dst            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0x9f  |any    |1     |0x00|dst = (src != 0) ? (dst |divmul64|Arithmetic   |
   |      |       |      |    |s% src) : dst           |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xa4  |0x0    |0     |any |dst = (u32)(dst ^ imm)  |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xa5  |0x0    |any   |any |if dst < imm goto       |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xa6  |0x0    |any   |any |if (u32)dst < imm goto  |base32  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xa7  |0x0    |0     |any |dst ^= imm              |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xac  |any    |0     |0x00|dst = (u32)(dst ^ src)  |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xad  |any    |any   |0x00|if dst < src goto       |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xae  |any    |any   |0x00|if (u32)dst < (u32)src  |base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xaf  |any    |0     |0x00|dst ^= src              |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xb4  |0x0    |0     |any |dst = (u32) imm         |base32  |Arithmetic   |



Thaler                  Expires 25 November 2024               [Page 38]

Internet-Draft                   BPF ISA                        May 2024


   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xb5  |0x0    |any   |any |if dst <= imm goto      |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xb6  |0x0    |any   |any |if (u32)dst <= imm goto |base32  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xb7  |0x0    |0     |any |dst = imm               |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xbc  |any    |0     |0x00|dst = (u32) src         |base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xbc  |any    |8     |0x00|dst = (u32) (s32) (s8)  |base32  |Arithmetic   |
   |      |       |      |    |src                     |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xbc  |any    |16    |0x00|dst = (u32) (s32) (s16) |base32  |Arithmetic   |
   |      |       |      |    |src                     |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xbd  |any    |any   |0x00|if dst <= src goto      |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xbe  |any    |any   |0x00|if (u32)dst <= (u32)src |base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xbf  |any    |0     |0x00|dst = src               |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xbf  |any    |8     |0x00|dst = (s64) (s8) src    |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xbf  |any    |16    |0x00|dst = (s64) (s16) src   |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xbf  |any    |32    |0x00|dst = (s64) (s32) src   |base64  |Arithmetic   |



Thaler                  Expires 25 November 2024               [Page 39]

Internet-Draft                   BPF ISA                        May 2024


   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc3  |any    |any   |0x00|lock *(u32 *)(dst +     |atomic32|Atomic       |
   |      |       |      |    |offset) += src          |        |operations   |
   |      |       |      |    |                        |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc3  |any    |any   |0x01|src =                   |atomic32|Atomic       |
   |      |       |      |    |atomic_fetch_add_32((u32|        |operations   |
   |      |       |      |    |*)(dst + offset), src)  |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc3  |any    |any   |0x40|lock *(u32 *)(dst +     |atomic32|Atomic       |
   |      |       |      |    |offset) |= src          |        |operations   |
   |      |       |      |    |                        |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc3  |any    |any   |0x41|src =                   |atomic32|Atomic       |
   |      |       |      |    |atomic_fetch_or_32((u32 |        |operations   |
   |      |       |      |    |*)(dst + offset), src)  |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc3  |any    |any   |0x50|lock *(u32 *)(dst +     |atomic32|Atomic       |
   |      |       |      |    |offset) &= src          |        |operations   |
   |      |       |      |    |                        |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc3  |any    |any   |0x51|src =                   |atomic32|Atomic       |
   |      |       |      |    |atomic_fetch_and_32((u32|        |operations   |
   |      |       |      |    |*)(dst + offset), src)  |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc3  |any    |any   |0xa0|lock *(u32 *)(dst +     |atomic32|Atomic       |
   |      |       |      |    |offset) ^= src          |        |operations   |
   |      |       |      |    |                        |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc3  |any    |any   |0xa1|src =                   |atomic32|Atomic       |
   |      |       |      |    |atomic_fetch_xor_32((u32|        |operations   |
   |      |       |      |    |*)(dst + offset), src)  |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc3  |any    |any   |0xe1|src = xchg_32((u32      |atomic32|Atomic       |
   |      |       |      |    |*)(dst + offset), src)  |        |operations   |
   |      |       |      |    |                        |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc3  |any    |any   |0xf1|r0 = cmpxchg_32((u32    |atomic32|Atomic       |
   |      |       |      |    |*)(dst + offset), r0,   |        |operations   |
   |      |       |      |    |src)                    |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc4  |0x0    |0     |any |dst = (u32)(dst s>> imm)|base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc5  |0x0    |any   |any |if dst s< imm goto      |base64  |Jump         |



Thaler                  Expires 25 November 2024               [Page 40]

Internet-Draft                   BPF ISA                        May 2024


   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc6  |0x0    |any   |any |if (s32)dst s< (s32)imm |base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xc7  |0x0    |0     |any |dst s>>= imm            |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xcc  |any    |0     |0x00|dst = (u32)(dst s>> src)|base32  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xcd  |any    |any   |0x00|if dst s< src goto      |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xce  |any    |any   |0x00|if (s32)dst s< (s32)src |base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xcf  |any    |0     |0x00|dst s>>= src            |base64  |Arithmetic   |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.1)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xd4  |0x0    |0     |0x10|dst = htole16(dst)      |base32  |Byte swap    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.2)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xd4  |0x0    |0     |0x20|dst = htole32(dst)      |base32  |Byte swap    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.2)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xd4  |0x0    |0     |0x40|dst = htole64(dst)      |base64  |Byte swap    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.2)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xd5  |0x0    |any   |any |if dst s<= imm goto     |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xd6  |0x0    |any   |any |if (s32)dst s<= (s32)imm|base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xd7  |0x0    |0     |0x10|dst = bswap16(dst)      |base32  |Byte swap    |



Thaler                  Expires 25 November 2024               [Page 41]

Internet-Draft                   BPF ISA                        May 2024


   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.2)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xd7  |0x0    |0     |0x20|dst = bswap32(dst)      |base32  |Byte swap    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.2)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xd7  |0x0    |0     |0x40|dst = bswap64(dst)      |base64  |Byte swap    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.2)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdb  |any    |any   |0x00|lock *(u64 *)(dst +     |atomic64|Atomic       |
   |      |       |      |    |offset) += src          |        |operations   |
   |      |       |      |    |                        |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdb  |any    |any   |0x01|src =                   |atomic64|Atomic       |
   |      |       |      |    |atomic_fetch_add_64((u64|        |operations   |
   |      |       |      |    |*)(dst + offset), src)  |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdb  |any    |any   |0x40|lock *(u64 *)(dst +     |atomic64|Atomic       |
   |      |       |      |    |offset) |= src          |        |operations   |
   |      |       |      |    |                        |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdb  |any    |any   |0x41|src =                   |atomic64|Atomic       |
   |      |       |      |    |atomic_fetch_or_64((u64 |        |operations   |
   |      |       |      |    |*)(dst + offset), src)  |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdb  |any    |any   |0x50|lock *(u64 *)(dst +     |atomic64|Atomic       |
   |      |       |      |    |offset) &= src          |        |operations   |
   |      |       |      |    |                        |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdb  |any    |any   |0x51|src =                   |atomic64|Atomic       |
   |      |       |      |    |atomic_fetch_and_64((u64|        |operations   |
   |      |       |      |    |*)(dst + offset), src)  |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdb  |any    |any   |0xa0|lock *(u64 *)(dst +     |atomic64|Atomic       |
   |      |       |      |    |offset) ^= src          |        |operations   |
   |      |       |      |    |                        |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdb  |any    |any   |0xa1|src =                   |atomic64|Atomic       |
   |      |       |      |    |atomic_fetch_xor_64((u64|        |operations   |
   |      |       |      |    |*)(dst + offset), src)  |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdb  |any    |any   |0xe1|src = xchg_64((u64      |atomic64|Atomic       |
   |      |       |      |    |*)(dst + offset), src)  |        |operations   |
   |      |       |      |    |                        |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdb  |any    |any   |0xf1|r0 = cmpxchg_64((u64    |atomic64|Atomic       |



Thaler                  Expires 25 November 2024               [Page 42]

Internet-Draft                   BPF ISA                        May 2024


   |      |       |      |    |*)(dst + offset), r0,   |        |operations   |
   |      |       |      |    |src)                    |        |(Section 5.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdc  |0x0    |0     |0x10|dst = htobe16(dst)      |base32  |Byte swap    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.2)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdc  |0x0    |0     |0x20|dst = htobe32(dst)      |base32  |Byte swap    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.2)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdc  |0x0    |0     |0x40|dst = htobe64(dst)      |base64  |Byte swap    |
   |      |       |      |    |                        |        |instructions |
   |      |       |      |    |                        |        |(Section 4.2)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xdd  |any    |any   |0x00|if dst s<= src goto     |base64  |Jump         |
   |      |       |      |    |+offset                 |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+
   |0xde  |any    |any   |0x00|if (s32)dst s<= (s32)src|base32  |Jump         |
   |      |       |      |    |goto +offset            |        |instructions |
   |      |       |      |    |                        |        |(Section 4.3)|
   +------+-------+------+----+------------------------+--------+-------------+

           Table 18: BPF Instruction sub-registry initial values

10.  References

10.1.  Normative References

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https://www.rfc-editor.org/rfc/rfc8126>.

10.2.  Informative References

   [LINUX]    "eBPF verifier",
              <https://www.kernel.org/doc/html/latest/bpf/
              verifier.html>.

   [PREVAIL]  Gershuni, E., Amit, N., Gurfinkel, A., Narodytska, N.,
              Navas, J., Rinetzky, N., Ryzhyk, L., and M. Sagiv, "Simple
              and Precise Static Analysis of Untrusted Linux Kernel
              Extensions", DOI 10.1145/3314221.3314590, June 2019,
              <https://doi.org/10.1145/3314221.3314590>.





Thaler                  Expires 25 November 2024               [Page 43]

Internet-Draft                   BPF ISA                        May 2024


Author's Address

   Dave Thaler (editor)
   Redmond, WA 98052
   United States of America
   Email: dave.thaler.ietf@gmail.com













































Thaler                  Expires 25 November 2024               [Page 44]
